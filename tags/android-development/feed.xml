<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android Development on Le murmure de Julian</title><link>https://blog.jln.co/tags/android-development/</link><description>Recent content in Android Development on Le murmure de Julian</description><generator>Hugo</generator><language>zh-tw</language><managingEditor>julianshen22@gmail.com (Julian Shen)</managingEditor><webMaster>julianshen22@gmail.com (Julian Shen)</webMaster><lastBuildDate>Wed, 20 Aug 2014 00:24:16 +0000</lastBuildDate><atom:link href="https://blog.jln.co/tags/android-development/feed.xml" rel="self" type="application/rss+xml"/><item><title>[Android] 土製Play store API</title><link>https://blog.jln.co/Android-%E5%9C%9F%E8%A3%BDPlay-store-API/</link><pubDate>Wed, 20 Aug 2014 00:24:16 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-%E5%9C%9F%E8%A3%BDPlay-store-API/</guid><description>&lt;p&gt;認真說的話, 這也算不上啥非官方API, 算是一個為了抓取Play store上資訊的一個小小工具: &lt;a href="https://github.com/julianshen/PlaystoreUtil"&gt;PlaystoreUtil&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在很多網路的服務, 大多有提供開放的REST API來供人寫原生的程式使用, 當然也有非常多並沒有, 像是Play store, 目前就沒開放的API可供存取, 剛好想要有個東西可以查詢某個app在play store上是屬於啥分類的, 所以就乾脆自己自製一個囉&amp;hellip;&lt;/p&gt;</description></item><item><title>[Android開發] 抓取網頁縮圖</title><link>https://blog.jln.co/Android%E9%96%8B%E7%99%BC-%E6%8A%93%E5%8F%96%E7%B6%B2%E9%A0%81%E7%B8%AE%E5%9C%96/</link><pubDate>Tue, 29 Jul 2014 00:36:15 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android%E9%96%8B%E7%99%BC-%E6%8A%93%E5%8F%96%E7%B6%B2%E9%A0%81%E7%B8%AE%E5%9C%96/</guid><description>&lt;p&gt;Phantom.js好用的地方就是可以以下面這一段簡單的程式來抓取網頁的縮圖:&lt;/p&gt;
&lt;pre&gt;var page = require('webpage').create();
page.open('http://github.com/', function() {
 page.render('github.png');
 phantom.exit();
}); 
&lt;/pre&gt;
&lt;p&gt;結果是像這樣:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://67.media.tumblr.com/97773b87c9fb0f318848c4faf603fdae/tumblr_inline_n9fjyu6dIP1qzg4zq.png"/&gt;&lt;/p&gt;
&lt;p&gt;不過, 這邊要說的並不是Phantom.js, 而是在Android上怎像這樣抓網頁縮圖&lt;/p&gt;</description></item><item><title>[Android] Retrofit + Signpost : 替Retrofit加上OAuth支援</title><link>https://blog.jln.co/Android-Retrofit--Signpost-%E6%9B%BFRetrofit%E5%8A%A0%E4%B8%8AOAuth%E6%94%AF%E6%8F%B4/</link><pubDate>Sat, 29 Jun 2013 08:31:32 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-Retrofit--Signpost-%E6%9B%BFRetrofit%E5%8A%A0%E4%B8%8AOAuth%E6%94%AF%E6%8F%B4/</guid><description>看到Square發表的這個Retrofit - &lt;a href="http://bit.ly/167v72a"&gt;http://bit.ly/167v72a&lt;/a&gt; 蠻有趣的, 它的目的似乎是試圖的想要去簡化開發REST client, 開發者不用寫太多的邏輯, 只要寫一個Interface跟利用annotation就可以完成一個簡單的REST client:&lt;br/&gt;&lt;br/&gt;&lt;pre class="prettyprint prettyprinted" style="background-color: whitesmoke; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902); color: #666666; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 20px; margin-bottom: 20px; padding: 9.5px; white-space: pre-wrap; word-break: break-all; word-wrap: break-word;"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;interface&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt; &lt;/span&gt;&lt;span class="typ" style="color: #222222;"&gt;GitHubService&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt; &lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;{&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt;&lt;br/&gt;&lt;/span&gt;&lt;span class="lit"&gt;@GET&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;(&lt;/span&gt;&lt;span class="str" style="color: #32835b;"&gt;"/users/{user}/repos"&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;)&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt;&lt;br/&gt;&lt;/span&gt;&lt;span class="typ" style="color: #222222;"&gt;List&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ" style="color: #222222;"&gt;Repo&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt; listRepos&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;(&lt;/span&gt;&lt;span class="lit"&gt;@Path&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;(&lt;/span&gt;&lt;span class="str" style="color: #32835b;"&gt;"user"&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;)&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt; &lt;/span&gt;&lt;span class="typ" style="color: #222222;"&gt;String&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt; user&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;);&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt;&lt;br/&gt;&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;div&gt;&lt;span class="pun" style="color: #888888;"&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;因為開發者只需要寫interface和annotation, 實質上並不用寫任何的code, 真正實作的部份他用了Proxy class的技巧包裝起來了, 這作法讓我想起來很久之前我在之前的工作幫公司寫的一個legacy系統的wrapper, 那時有很多機器產生的interface, 如果人工一個個實作很浪費時間, Proxy class可以解決掉這一部分的問題, 同樣的在retrofit似乎也是想用這技巧節省實作&lt;br/&gt;&lt;br/&gt;但可惜的是, 現在的retrofit並還沒加入OAuth的支援, 因此送出去的API部分並沒被oauth簽章過,不過所幸要解決這一部分也不難, 寫一個Client class搭配&lt;a href="http://bit.ly/11OBeF8" target="_blank"&gt;Signpost&lt;/a&gt;還是可以做到, 這邊範例繼承了OkClient(使用OkHttp) :&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;script src="http://bit.ly/14BPkrJ"&gt;&lt;/script&gt;&lt;br/&gt;因為OkHttp也是一種HttpURLConnection, 因此Signpost搭配DefaultOAuthProvider和DefaultOAuthConsumer即可, 另外初始化RestAdapter時加上這個新的Client即可:&lt;br/&gt;&lt;br/&gt;&lt;blockquote class="tr_bq"&gt;RestAdapter restAdapter = new RestAdapter.Builder() .setClient(new SignedOkClient(mConsumer)) &lt;/blockquote&gt;&lt;br/&gt;&lt;br/&gt;
via Blogger &lt;a href="http://bit.ly/11OBeFb"&gt;http://bit.ly/11OBeFb&lt;/a&gt;</description></item><item><title>[Android] 自定義View屬性</title><link>https://blog.jln.co/Android-%E8%87%AA%E5%AE%9A%E7%BE%A9View%E5%B1%AC%E6%80%A7/</link><pubDate>Thu, 27 Jun 2013 01:46:42 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-%E8%87%AA%E5%AE%9A%E7%BE%A9View%E5%B1%AC%E6%80%A7/</guid><description>&lt;p&gt;在&lt;a href="http://bit.ly/14xA3IP" target="_blank"&gt;前一篇寫了一個自訂義的layout - SimpleCellLayout&lt;/a&gt;, 前一個版本的問題就是, 必須是寫程式把child view加進這個layout之中, 而且針對像是欄與行的數目也必須在程式裡設定, 並無法寫到layout xml中, 所以這次的目邊就是要讓這個layout可以像下面這樣用layout xml來擺佈:&lt;br/&gt;&lt;br/&gt;&lt;script src="http://bit.ly/1af6Kkh"&gt;&lt;/script&gt;&lt;br/&gt;在這範例之中, 用到幾個像是col, row, gapsize, cellX這些在原生Android並不存在的屬性, 為了這些屬性, 就需要定義一個attrs.xml在res/values目錄內, attrs.xml 裡面要定義的就是這些樣式描述屬性, 這邊定義了: 給SimpleCellLayout本身用的col(欄數), row(行數), gapsize(間距大小), 以及給他的Child views用的cellX(格子的橫軸位置), cellY(格子的縱軸位置), colspan(格子寬), rowspan(格子高), 除了gapsize我們需要的跟實際螢幕上的大小有關, 所以格式定義為dimension外(就是可以用3dp, 1px這類的值), 其他都是整數就可&lt;br/&gt;&lt;br/&gt;&lt;script src="http://bit.ly/14xA5Ap"&gt;&lt;/script&gt; 這些屬性, 到時候就是要放在xml標籤內的屬性 &lt;br/&gt;&lt;br/&gt;要用到這些屬性, 需要先在tag裡面定義一個新的name space, 如同在前面範例寫的:&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;</description></item><item><title>[Android] 一個簡單的自製 layout - SimpleCellLayout</title><link>https://blog.jln.co/Android-%E4%B8%80%E5%80%8B%E7%B0%A1%E5%96%AE%E7%9A%84%E8%87%AA%E8%A3%BD-layout-SimpleCellLayout/</link><pubDate>Wed, 26 Jun 2013 01:31:50 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-%E4%B8%80%E5%80%8B%E7%B0%A1%E5%96%AE%E7%9A%84%E8%87%AA%E8%A3%BD-layout-SimpleCellLayout/</guid><description>&lt;p&gt;寫Android寫了這麼久, 才想到自己沒寫過custom layout, 剛剛花了點時間(主要時間還是花在跟Android studio和gradle搏鬥)寫了一個簡單的CellLayout (還很陽春) :&lt;br/&gt;&lt;br/&gt;&lt;a href="http://bit.ly/12nuhGn"&gt;http://bit.ly/12nuhGn&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;寫custom layout還蠻簡單的, 在onMeasure決定自己和child views的大小, 在onLayout時把每個child views放到適當的位置, 目前還沒加入attibrtues的支援, 所以暫時還只能寫code自己把view加進去, 另外也還沒加檢查是不是會有重疊的views, 之後再來寫&lt;br/&gt;&lt;br/&gt;這個layout跟GridView不同, 可以不用每個格子都是同一大小, 以下範例是把畫面劃成4x4的格子, 左上角的那張圖大小是2x2, 下方則是 4x2&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;</description></item><item><title>[Android] 圓形大頭貼 - 使用Picasso的Transformation</title><link>https://blog.jln.co/Android-%E5%9C%93%E5%BD%A2%E5%A4%A7%E9%A0%AD%E8%B2%BC-%E4%BD%BF%E7%94%A8Picasso%E7%9A%84Transformation/</link><pubDate>Sat, 22 Jun 2013 01:31:57 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-%E5%9C%93%E5%BD%A2%E5%A4%A7%E9%A0%AD%E8%B2%BC-%E4%BD%BF%E7%94%A8Picasso%E7%9A%84Transformation/</guid><description>現在不管是Google+也好, 或是Facebook (Home), 似乎都很喜歡用圓形的大頭貼像這樣 (左上角圖形, &lt;br/&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://bit.ly/10Ea6Kt" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="400" src="http://bit.ly/11DoFZH" width="225"/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br/&gt;但在server端存的大頭照其實都是都是方形的, 所以必須抓下來後再轉畫成圓的, 最近從網路抓圖的部分, 我還蠻喜歡用&lt;a href="http://bit.ly/10Ea9FT" target="_blank"&gt;Picasso&lt;/a&gt;的&lt;br/&gt;&lt;br/&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://bit.ly/11DoFZJ" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="191" src="http://bit.ly/11DoFZJ" width="400"/&gt;&lt;/a&gt;&lt;/div&gt;沒啥別的原因, 就是它簡單, 雖然說, 它似乎還是有一些小小問題, 不過它可以用這樣短短一行解決圖檔下載並顯示到ImageView的一連串動作:&lt;br/&gt;&lt;br/&gt;&lt;pre class="prettyprint prettyprinted" style="background-color: whitesmoke; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902); color: #666666; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 20px; margin-bottom: 20px; padding: 9.5px; white-space: pre-wrap; word-break: break-all; word-wrap: break-word;"&gt;&lt;span style="background-color: #eeeeee;"&gt;&lt;span class="typ" style="color: #222222;"&gt;Picasso&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;with&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;(&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt;context&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;).&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt;load&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;(&lt;/span&gt;&lt;span class="str" style="color: #953a39;"&gt;"http://bit.ly/11DoFZL"&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;).&lt;/span&gt;&lt;span class="kwd"&gt;into&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;(&lt;/span&gt;&lt;span class="pln" style="color: black;"&gt;imageView&lt;/span&gt;&lt;span class="pun" style="color: #888888;"&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;div&gt;&lt;br/&gt;不過, 簡單的代價可能在其他的地方來說彈性就不高了, 不過, 做這樣一個小玩意兒的彈性倒是還有, 在Picasso中, 可以實作Transformation把下載下來的圖檔再作一次後處理, 在它的網頁有一個CropSquareTransformation的範例, 圓形的大頭貼可以視為這一個的延伸:&lt;/div&gt;&lt;div&gt;&lt;br/&gt;&lt;/div&gt;&lt;div&gt;&lt;script src="http://bit.ly/10Ea996"&gt;&lt;/script&gt;&lt;/div&gt;&lt;div&gt;這邊利用了BitmapShader重畫了一張圓形的大頭貼, 出來的結果就會像是這樣:&lt;br/&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://bit.ly/11DoFZP" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="400" src="http://bit.ly/10Ea998" width="225"/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br/&gt;&lt;/div&gt;&lt;div&gt;&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;
via Blogger &lt;a href="http://bit.ly/11DoEVG"&gt;http://bit.ly/11DoEVG&lt;/a&gt;</description></item><item><title>[Android] 一閃一閃亮晶晶的BlinkLayout</title><link>https://blog.jln.co/Android-%E4%B8%80%E9%96%83%E4%B8%80%E9%96%83%E4%BA%AE%E6%99%B6%E6%99%B6%E7%9A%84BlinkLayout/</link><pubDate>Thu, 20 Jun 2013 20:16:26 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-%E4%B8%80%E9%96%83%E4%B8%80%E9%96%83%E4%BA%AE%E6%99%B6%E6%99%B6%E7%9A%84BlinkLayout/</guid><description>&lt;p&gt;在&lt;a href="https://developers.google.com/events/io/sessions/324958375" target="_blank"&gt;Androids Do Daydream&lt;/a&gt;裡有提到Romain Guy要他提(大概假的吧)在layout裡面放&amp;quot;&amp;lt;blink&amp;gt;&amp;ldquo;可以做到view閃爍的效果而不用寫到一行code&lt;br/&gt;&lt;br/&gt;查了一下AOSP的原始碼也的確有這東西, 它是一個躲在&lt;a href="https://github.com/android/platform_frameworks_base/blob/5cb0f2184656642160e9ac032d0646f766058a5b/core/java/android/view/LayoutInflater.java" target="_blank"&gt;LayoutInflater&lt;/a&gt;的一個叫BlinkLayout的東西, 這樣一來就可以配合&lt;a href="http://developer.android.com/reference/android/widget/TextClock.html" target="_blank"&gt;TextClock&lt;/a&gt; (API Level 17)來做一個閃爍的時鐘了&lt;br/&gt;&lt;br/&gt;&lt;script src="https://gist.github.com/julianshen/5822197.js"&gt;&lt;/script&gt;&lt;br/&gt;不過, 這樣, 是整個TextClock在閃, 而不是像一般數字鐘一樣是只有&amp;rdquo;:&amp;ldquo;閃, 如果要做到只有&amp;rdquo;:&amp;ldquo;在閃, 那只好把&amp;quot;時&amp;quot;跟&amp;quot;分&amp;quot;給拆開, 像這樣: &lt;br/&gt;&lt;br/&gt;&lt;script src="https://gist.github.com/julianshen/5822234.js"&gt;&lt;/script&gt;&lt;br/&gt;&lt;br/&gt;
via Blogger &lt;a href="http://julianshen.blogspot.com/2013/06/android-blinklayout.html"&gt;http://julianshen.blogspot.com/2013/06/android-blinklayout.html&lt;/a&gt;&lt;/p&gt;</description></item><item><title>[筆記][Android Studio]Git push</title><link>https://blog.jln.co/%E7%AD%86%E8%A8%98Android-StudioGit-push/</link><pubDate>Mon, 17 Jun 2013 09:46:39 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/%E7%AD%86%E8%A8%98Android-StudioGit-push/</guid><description>&lt;p&gt;本想說有直接整合了Git, GitHub是件不錯的事, 沒想到要把新project push到remote git就栽了&amp;hellip;.&lt;br/&gt;&lt;br/&gt;Android Studio/Intellij 似乎沒介面設定remote (搜尋了半天沒發現這種答案, 啃了半天的使用手冊也沒發現), 現在如果要把既有的project給匯出到遠端的git (如bitbucket), 就得利用command line (以bitbucket 為例):&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;</description></item><item><title>[筆記] Android Studio, Gradle &amp; Native libraries</title><link>https://blog.jln.co/%E7%AD%86%E8%A8%98-Android-Studio-Gradle-Native-libraries/</link><pubDate>Sun, 16 Jun 2013 00:01:29 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/%E7%AD%86%E8%A8%98-Android-Studio-Gradle-Native-libraries/</guid><description>&lt;p&gt;最近試用Android studio開發, 可能有些習慣被以往Eclipse慣壞了, 剛剛發現放在libs/底下的東西不像以前會被自動建置到apk內, 有點小訝異, 對jar file來說, 可能還好不算太難, 在build.gradle的dependencies內補上一筆就夠了, 但對native library (jni)那些.so檔, 就沒辦法&lt;br/&gt;&lt;br/&gt;用這樣解決了 Google了一下, 並且在Stack overflow上找到些解法來試, 可能因為Android studio跟Gradle Android plugin還一直在變化中, 在現在這版一直沒成功, 後來小改一下成底下這樣就成功了: &lt;br/&gt;&lt;script src="http://bit.ly/11PxIJZ"&gt;&lt;/script&gt;&lt;br/&gt;&lt;br/&gt;原本找到的解法是pkgTask.jniDir &lt;b&gt;&lt;span style="color: red;"&gt;new File&lt;/span&gt;&lt;/b&gt;(&amp;lsquo;build/native-libs&amp;rsquo;) , 這樣會得到&lt;br/&gt;&lt;/p&gt;</description></item><item><title>[Android dev] JsonReader</title><link>https://blog.jln.co/Android-dev-JsonReader/</link><pubDate>Tue, 02 Apr 2013 02:02:33 +0000</pubDate><author>julianshen22@gmail.com (Julian Shen)</author><guid>https://blog.jln.co/Android-dev-JsonReader/</guid><description>原本在Android下解析JSON內容,  大多用&lt;a href="http://bit.ly/14AliYI" target="_blank"&gt;JSONObject&lt;/a&gt;和&lt;a href="http://bit.ly/16rSIaD" target="_blank"&gt;JSONArray&lt;/a&gt;, 這兩個是很簡單的JSON parser, 只要將字串(String)傳入即可&lt;br/&gt;&lt;br/&gt;不過, 這跟在用DOM解析XML是有類似的問題, 解析文件是一氣呵成, 必須要把所有內容先走過一遍, 也需要更多的記憶體來儲存, 這對於解析較大的文件是一個大問題, 必須要花費更多時間和空間, 而且如果所需要的資料就算只是整份文件中間的一小部分, 還是得先把整份文件走完, 在XML, 可以用SAX來解決這問題, 但Android要到API level 11(Honeycomb) 才新增了&lt;a href="http://bit.ly/14AljMq" target="_blank"&gt;JsonReader&lt;/a&gt;這個算是JSON界的SAX的解決方案&lt;br/&gt;&lt;br/&gt; &lt;a href="http://bit.ly/14AljMq" target="_blank"&gt;JsonReader&lt;/a&gt;類似SAX, 也是一種streaming parser, 並不用一次讀出所有字串內容, 它要的只是個Reader, 但不太像SAX屬於事件驅動(event driven)的方式, 它應該比較像token consuming, 它定義了幾類基本的&lt;a href="http://bit.ly/14AljMr" target="_blank"&gt;JsonToken&lt;/a&gt;,  它也有BEGIN(END)_OBJECT, BEGIN(END)_ARRAY這種類似SAX中startElement, endElement, 但卻沒類似SAX的startDocument&lt;br/&gt;&lt;br/&gt;解析一個JSON物件的程式碼如下:&lt;br/&gt;&lt;br/&gt;&lt;blockquote class="tr_bq"&gt;&lt;pre&gt;&lt;b&gt; &lt;span style="color: #990000;"&gt; {username:"Bob", age: 14, sex: "m"}&lt;/span&gt;&lt;/b&gt;&lt;span style="color: #990000;"&gt; &lt;/span&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;blockquote class="tr_bq"&gt;&lt;pre&gt;&lt;b&gt; reader.beginObject();&lt;/b&gt;&lt;br/&gt; while (reader.hasNext()) {&lt;br/&gt; String name = &lt;b&gt;reader.nextName();&lt;/b&gt;&lt;br/&gt; if (name.equals("username")) {&lt;br/&gt; username = reader.nextString();&lt;br/&gt; } else if (name.equals("age")) {&lt;br/&gt; followersCount = reader.nextInt();&lt;br/&gt; } &lt;span style="color: #990000;"&gt;else {&lt;br/&gt; reader.skipValue();&lt;br/&gt; }&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;b&gt;reader.endObject();&lt;/b&gt;&lt;/pre&gt;&lt;/blockquote&gt;解析一個物件, 要從beginObject開始(陣列則是beginArray), endObject結束, 接著透過一個while loop一個個走過這物件內所有的token, 說實在的, 不是很好debug,  你必須要先知道下一個要處理的token是啥類別, 以上面的例子為例, 物件內第一個token是&amp;quot;username&amp;quot;, 這是一個JsonToken.NAME, 因此要用nextName來處理, 搞錯了就會出錯, 還不容易知道錯哪,  而上面那例子裡的&amp;quot;else&amp;quot;也是必須的, 拿掉的話, 在endObject就會出錯, 因為這段程式並沒去處理&amp;quot;sex&amp;quot;, 因此處理完sex這個名字後, 並未消化掉&amp;quot;m&amp;quot;這個值(JsonToken.STRING), 而是直接endObject, 這會產生一個IllegalStateException&lt;br/&gt;&lt;br/&gt;為了避免用了錯誤的方式處理下一個token, 可以先用&lt;a href="http://bit.ly/16rSFLX" target="_blank"&gt;peek()&lt;/a&gt;來看一下下一個要處理的種類&lt;br/&gt;&lt;br/&gt;在可讀性上, 用JsonReader寫出的並不是很好, 但它卻適合來處理大的JSON文件, 或是像Twitter Streaming API這種幾乎無止盡的&lt;br/&gt;&lt;br/&gt;這當然也不是只有在Android上有, Google也早把這也&lt;a href="http://bit.ly/14AljMt" target="_blank"&gt;包含到GSON去了&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;
via Blogger &lt;a href="http://bit.ly/16rSFLZ"&gt;http://bit.ly/16rSFLZ&lt;/a&gt;</description></item></channel></rss>