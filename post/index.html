<!doctype html><!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=en><![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang=en><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang=en><![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en><!--<![endif]--><head><meta charset=utf-8><title>Posts &#8211; Le murmure de Julian</title><meta name=description content><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.jln.co/post/"><meta property="og:image" content="https://blog.jln.co/images/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.jln.co/images/avatar.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content><link rel=canonical href=https://blog.jln.co/post/><link rel=alternate type=application/rss+xml href=https://blog.jln.co/post/feed.xml title="Le murmure de Julian"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/main.css><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel=stylesheet type=text/css><meta http-equiv=cleartype content="on"><meta name=generator content="Hugo 0.118.2"><script src=/js/vendor/modernizr-2.6.2.custom.min.js></script>
<script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script>
<link rel="shortcut icon" href=/favicon.png></head><body id=post-index class=feature><nav id=dl-menu class=dl-menuwrapper role=navigation style=display:inline-block><button class=dl-trigger>Open Menu</button><ul class=dl-menu><li><a href=/>Home</a></li><li><a href=#>About</a><ul class=dl-submenu><li><img src=/images/avatar.png alt="Julian Shen's photo" class=author-photo><h4>Julian Shen</h4><p>Softward developer</p></li><li><a href=mailto:julianshen22@gmail.com><i class="fa fa-fw fa-envelope"></i> Email</a></li><li><a href=https://linkedin.com/in/julianshen><i class="fa fa-fw fa-linkedin"></i> LinkedIn</a></li><li><a href=https://github.com/julianshen><i class="fa fa-fw fa-github"></i> GitHub</a></li><li><a href=https://instagram.com/julianshen><i class="fa fa-fw fa-instagram"></i> Instagram</a></li></ul></li><li><a href=#>Posts</a><ul class=dl-submenu><li><a href=/post/>All Posts</a></li><li><a href=/tags/>All Tags</a></li></ul></li><li><a href=/></a></li></ul></nav><div class=entry-header><div class=image-credit>Image credit: <a href=http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/>dargadgetz</a></div><div class=entry-image><img src=/abstract-2.jpg alt=Posts></div><div class=header-title><div class=header-title-wrap><h1><a href=/ title="Go to the homepage">Le murmure de Julian</a></h1><h2>All posts</h2></div></div></div><div id=main role=main><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2023-09-19 01:38:36 +0800 +0800"><a href=/Yong-Natslai-Shi-Xian-Fen-San-Shi-Wei-Fu-Wu/>Sep 19, 2023</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~4 minutes</span></div><h1 class=entry-title><a href=/Yong-Natslai-Shi-Xian-Fen-San-Shi-Wei-Fu-Wu/ rel=bookmark title=用NATS來實現分散式微服務 itemprop=url>用NATS來實現分散式微服務</a></h1></header><div class=entry-content><p>在近幾年, 微服務(Micro service)架構大部分的人應該不陌生了, 不管是面試, 實戰, 應該都已經聽到快爛了, 不過, 這篇來講講一個基於NATS的做法</p><p>首先, 先來了解一下<a href=https://nats.io/about/>NATS到底是啥東西?</a>簡單來說, 它是一個輕量(Container image只有小小的18MB), 高效, 且安全的訊息佇列(Message Queue), 就基本的Pub/Sub用法來說, 它也的確像是這樣, 很容易就會把它跟Kafka, RabbitMQ等等歸為同一類, 那, 如果要談用Message Queue做微服務的溝通核心, 那有啥好講的? 不就是像是發佈訂閱(Pub Sub), 做成非同步架構, 那有啥好講的?</p><p>在微服務架構下, 要完成一件事, 各微服務之間的溝通是非常吃重的, 一般來說比較直覺的方式就是制定介面(API)來當作各微服務間溝通的協議, 微服務之間透過呼叫API的方式來與另一個服務做溝通, 不管是透過REST API或是透過gRPC, 這都屬於同步(Synchronized)的溝通方式, 也就是任一次呼叫在一定時間內都會預期有回覆(或錯誤)</p><p>再另一種方式就是利用Message Queue做成非同步的做法, 也就是呼叫方把訊息發佈到Message Queue內, 再由另一方訂閱方把訊息收去處理, 因為每次呼叫並不會需要預期有回應的結果, 呼叫方把訊息發佈後, 就不理了, 所以也就不會造成程式的阻塞, 適合需要處理很久的操作, 缺點就是呼叫方不容易拿到執行結果</p><p>如果只是要講後者, 那這篇講到這邊差不多就可以下課了(那我還寫幹嘛), 其實NATS的目標應該不僅止于Message queue, 由網站上寫的<a href=https://nats.io/about/>有關NATS的相關內容</a>, 可以知道它目標是作分散式應用程式的中樞神經系統, 所以其實除了非同步的方式外, 也可以識做成同步架構</p><h2 id=request-reply>Request-Reply</h2><p>前面有說到, 微服務間的溝通方式, 其中一種就是一個微服務透過API呼叫另一個微服務, 而這個API可以預期的狀況是:</p><ol><li>成功並取得結果</li><li>失敗並取得錯誤相關訊息</li><li>在等待一段時間後(timeout), 呼叫失敗</li></ol><p>NATS也提供機制讓你達成這樣的結果, 雖然NATS的基本就是Pub Sub, 但還是提供了Request/Reply的做法</p><p>不多囉唆, 先看一下程式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>    <span style=color:#a6e22e>nc</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>urls</span>, <span style=color:#a6e22e>opts</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>nc</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>subj</span>, <span style=color:#a6e22e>payload</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>0</span>], []byte(<span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>msg</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nc</span>.<span style=color:#a6e22e>Request</span>(<span style=color:#a6e22e>subj</span>, <span style=color:#a6e22e>payload</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nc</span>.<span style=color:#a6e22e>LastError</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;%v for request&#34;</span>, <span style=color:#a6e22e>nc</span>.<span style=color:#a6e22e>LastError</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;%v for request&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>上頭這隻程式是一個 <strong>&ldquo;requester&rdquo;</strong>, 他把請求送到一個NATS subject, 並且等待並接收回傳訊息, 其實看起來就跟一個publisher沒啥兩樣, 差別就是他會卡在那邊等待回應(或timeout)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>    <span style=color:#75715e>//Responder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>nc</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>urls</span>, <span style=color:#a6e22e>opts</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>subj</span>, <span style=color:#a6e22e>reply</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nc</span>.<span style=color:#a6e22e>QueueSubscribe</span>(<span style=color:#a6e22e>subj</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>queueName</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>msg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>Msg</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printMsg</span>(<span style=color:#a6e22e>msg</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Respond</span>([]byte(<span style=color:#a6e22e>reply</span>))
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nc</span>.<span style=color:#a6e22e>Flush</span>()
</span></span></code></pre></div><p>上面則是相對於 <strong>&ldquo;requester&rdquo;</strong> 的 <strong>&ldquo;responder&rdquo;</strong> , 其實跟個subscriber差不多, 就是把訊息接回來處理,多一個回傳的動作(<code>msg.Respond([]byte(reply))</code>)而已, 從抽象角度來看, 跟我們直接拿REST API實作有點類似:
<img src=/images/posts/restapi.png alt></p><p>但實際上, 他的做法比較是這樣的:</p><p><img src=/images/posts/reqresp.png alt></p><p>好像不太意外, 但這樣有啥好處, 我不就直接寫rest不就好了? 我們先來看一下負載平衡的做法好了:</p><p><img src=/images/posts/lbrrr.png alt></p><p>在這做法下, NATS其實就擔當起load balancer這角色了, 其實, 不知道你有沒注意到, 他也兼顧了service discovery的角色, 傳統你呼叫一個API service, 你必須先知道他的endpoint, 但在這邊你只要知道subject就好了, 因為responder是在監聽著那個subject, 因此, 還可以變形成這樣:</p><p><img src=/images/posts/crosszoneee.png alt></p><p>就可以簡單的實現到跨區呼叫或故障轉移(failover)</p><h2 id=nats-service-api>NATS Service API</h2><p>這應該是一個美麗(?)的未來, 不久前看到這段影片, 其實也真的就不久, 三月放出來的影片, 離現在也沒多久</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/byHGNUqIONw style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><p>剛開始看到覺得, 頗酷的呀, 感覺就是在原本request/reply機制上再加上更多像是monitor和tracing的機制, 並讓它變得更像RPC call</p><p>但為了寫這篇時, 做實驗後發現, 他講的東西目前也都還沒push到main trunk去的樣子, 像是schema, 說有支援typescript也還沒, 還有<code>nats service</code>相關的指令也都還沒有, main裡面還沒找到相關的source code</p><p>所以這篇就沒打算寫太多了, 免得未來差異太大, 相關細節還是可以去看那段影片</p><p>先簡單來看一下程式會長成怎樣:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#75715e>// GreeterServer is the server API for Greeter service.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GreeterServer</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Sends a greeting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SayHello</span>(<span style=color:#a6e22e>in</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>HelloRequest</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>HelloReply</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RegisterGreeterServer</span>(<span style=color:#a6e22e>conn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>nats_go</span>.<span style=color:#a6e22e>Conn</span>, <span style=color:#a6e22e>subject</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>greeter</span> <span style=color:#a6e22e>GreeterServer</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>srv</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>micro</span>.<span style=color:#a6e22e>AddService</span>(<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>micro</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Name</span>:    <span style=color:#e6db74>&#34;greeter&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Version</span>: <span style=color:#e6db74>&#34;1.0.0&#34;</span>,
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>grp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>AddGroup</span>(<span style=color:#a6e22e>subject</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>grp</span>.<span style=color:#a6e22e>AddEndpoint</span>(<span style=color:#e6db74>&#34;sayhello&#34;</span>, <span style=color:#a6e22e>micro</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>micro</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>HelloRequest</span>{}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Data</span>(), <span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>greeter</span>.<span style=color:#a6e22e>SayHello</span>(<span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>resp</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Respond</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>	}))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GreeterClient</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>subject</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>conn</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>nats_go</span>.<span style=color:#a6e22e>Conn</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewGreeterClient</span>(<span style=color:#a6e22e>conn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>nats_go</span>.<span style=color:#a6e22e>Conn</span>, <span style=color:#a6e22e>subject</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>GreeterClient</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>GreeterClient</span>{<span style=color:#a6e22e>subject</span>, <span style=color:#a6e22e>timeout</span>, <span style=color:#a6e22e>conn</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GreeterClient</span>) <span style=color:#a6e22e>SayHello</span>(<span style=color:#a6e22e>in</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>HelloRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>HelloReply</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>in</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>msg</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Request</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>subject</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;.sayhello&#34;</span>, <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timeout</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reply</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>HelloReply</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Data</span>, <span style=color:#a6e22e>reply</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reply</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這段client/server的程式就跟request/reply的感覺差不多, 只是多了一些東西</p><p>其實我也試著想結合grpc跟這機制, 因此寫個<a href=https://github.com/julianshen/npc/>小工具叫NPC</a>, 所以以上的程式其實是由底下這個定義產生的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> go_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nnrpc/pb&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// The greeting service definition.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - version: 1.0.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>service</span> Greeter {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#75715e>// Sends a greeting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>rpc</span> SayHello (HelloRequest) <span style=color:#66d9ef>returns</span> (HelloReply) {}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// The request message containing the user&#39;s name.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> name <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// The response message containing the greetings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloReply</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>message</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>(這邊就不談怎寫protoc的plugin了)</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2023-07-07 21:27:41 +0800 +0800"><a href=/Dead-or-Alive-Are-You-Ready/>Jul 7, 2023</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~6 minutes</span></div><h1 class=entry-title><a href=/Dead-or-Alive-Are-You-Ready/ rel=bookmark title="Dead or Alive? Are You Ready?" itemprop=url>Dead or Alive? Are You Ready?</a></h1></header><div class=entry-content><p>這篇主要是要來講K8S上的liveness probe/readiness probe/startup probe, 這應該是比較不會被注意到的題目, 大家可能會想, 不過就是health check嘛, 有啥難的? </p><p>不過其實在K8S上面其實不是只有單單health check這麼簡單, 它上面有liveness probe, readiness probe, startup probe, 每一種都有它的不同作用, 如果沒特別注意各自特性, 其實也是有可能會碰到災難的, 首先來看看, 怎麼使用這三種不同的"探針"(翻成探針好像怪怪的, 但我想不到比較好的說法)</p><p>這個定義是針對Pod (Deployment &mldr;), 所以你的YAML可能會像這樣</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>test</span>: <span style=color:#ae81ff>liveness</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>liveness-http</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>liveness</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>registry.k8s.io/liveness</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>args</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>/server</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/healthz</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>httpHeaders</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Custom-Header</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#ae81ff>Awesome</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>startupProbe</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/healthz</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>liveness-port</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>failureThreshold</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>10</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>readinessProbe</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/healthz</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>liveness-port</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>failureThreshold</span>: <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>10</span>   
</span></span></code></pre></div><p>先說一下, 上面並不是一個好寫法, 三種Probe都用了同一個endpoint, 先不多做解釋, 看完應該就比較會清楚啥不好</p><p>不管哪一種, 都有三種檢查機制可以用:</p><ul><li>exec 執行一個特別的命令, status code是0則是成功</li><li>grpc 呼叫grpc來確認狀態(參考 <a href=https://grpc.github.io/grpc/core/md_doc_health-checking.html>https://grpc.github.io/grpc/core/md_doc_health-checking.html</a>)</li><li>httpGet 呼叫HTTP GET來確認狀態, HTTP status 200-400(以內)都算成功</li><li>tcpSocket 可以建立連線就表示沒問題</li></ul><p>就是選擇適合來確認你服務的健康狀態的來使用就好了(廢話)</p><p>那這三種有啥分別?</p><ul><li>livenessProbe 用來確認你的服務是不是還在"執行", 如果不是, pod就會被砍掉, 然後會依據restartPolicy的設定是不是要重啟你的pod</li><li>readinessProbe 活著(liveness)和準備好(readiness)差別在哪? 這邊的readiness指的是你的容器(container), 是不是已經"準備好提供服務"了, 如果是, 才會把請求(request)轉送到你的容器</li><li>startupProbe 特性其實接近livenessProbe, 但是是用在容器剛啟動時, 用來確認容器是否正常啟動, 如果檢查失敗(時間超過 initialDelaySeconds[<em>一開始等多久</em>] + failureThreshold[<em>失敗幾次</em>] × periodSeconds[<em>間隔多久重試</em>])一樣是砍掉pod, 然後會依據restartPolicy的設定是不是要重啟你的pod</li></ul><p>詳細點來說,</p><h2 id=啥時用livenessprobe>啥時用livenessProbe?</h2><p>俗語說的好, &ldquo;<strong><code>重開機治百病</code></strong>"(哪來的俗語呀?), 簡單的說, 如果你的容器卡住不動了, 怎麼搖都懷疑人生, 沒反應了, 需要透過重開, 重新投胎, 才能(有機會)恢復正常, 那就是livenessProbe可以發揮的地方了</p><p>這邊說的是卡住不動沒回應這類的, 所以像是你的程式碰到dead lock, 無窮迴圈而無法正常回應都算, 但程式結束, 不正常離開(像Java的uncaught RuntimeException?) 其實不用等到livenessProbe打失敗, 就會照restartPolicy來處理, 所以可以知道, 當發現有Pod重啟的情形, 應該就不外乎是自然死, 意外死, 還有就是因為livenessProbe打施打失敗被謀殺了</p><p>那&mldr;.</p><h3 id=該不該在livenessprobe去檢查相關的服務或資料庫有沒活著>該不該在livenessProbe去檢查相關的服務或資料庫有沒活著?</h3><p>不該!(張惠妹/周杰倫), 這還蠻常見的狀況, 就想說, 這health check 嘛, 我資料庫連不上, 當然就不健康囉, 所以就回傳了Failure了, Spring boot acuator的health endpoint也是會幫你檢查相關依賴的資源的狀況列入檢查(不過它有為Kubernetes有對應的做法啦, 後面再說)</p><p>這樣會導致啥狀況? 你明明服務還好好的, 然後只是資料庫連不上, 結果你的Pod就被砍了(好無辜), 然後只要資料庫還沒修好, 就一直復活一直死(好悲哀)</p><p>所以liveness的probe應該簡單到只是確認這個容器有沒被卡死, 資料庫連不上只是不能服務, 資料庫修好了還是可以繼續服務呀</p><h3 id=老是因為打livenessprobe時timeout被砍-那我是不是盡量把timeoutseconds盡量設的越大越好>老是因為打livenessProbe時timeout被砍, 那我是不是盡量把timeoutSeconds盡量設的越大越好?</h3><p>其實這檢查的目的只是要確認容器有沒被卡死, 所以livenessProbe應該盡可能越簡單越好, 不太適合去做一些需要大量運算或是複雜的事, 因為那可能會因為你的pod或node的繁忙程度去影響到它執行時間長短差距很大, 那如果因為這樣去調高timeout時間也不太合理, 因為也很難確定要多久才能確定它"真的被卡住了&rdquo;, 再加上你可能會因為頻繁做這些複雜運算(因為每periodSecond會被探測一次)影響系統效能(像是不要在livenessProbe實作內call DB query)</p><p>依據你livenessProbe正常會回應的時間再多給點應該就足夠了, 設非常大的話, 搞不好容器真的卡住了, 但卻反應慢了</p><h3 id=我可不可以不要設livenessprobe>我可不可以不要設livenessProbe</h3><p>為何不可? 前面一直說, 它只是用來偵測程式是不是被"卡住了", 如果沒被卡死的風險, 不需要靠重啟手段來回復的話, 那不用設是可以呀</p><h2 id=那啥時用readinessprobe呢>那啥時用readinessProbe呢?</h2><p>readinessProbe跟livenessProbe的差異在於會不會出人(Pod)命, readiness為success的話, 上游(Service)才會把請求(request)送來給我處理, 不然的話, 就會收不到(又是廢話), 所以從這邊就可以看出前面那題的答案了, liveness和readniess的檢查邏輯應該會不一樣的(所以不太適合同一個endpoint搞定)</p><h3 id=那要不要去檢查相關的服務或資料庫有沒活著>那要不要去檢查相關的服務或資料庫有沒活著?</h3><p>可以, 也建議, 因為如果後面的服務或資料庫死了, 表示請求送進來也會處理失敗, 那不如先把它擋在外面等到服務正常了</p><h2 id=startupprobe呢>startupProbe呢?</h2><p>這個通常用在啟動會很久的容器, 為了怕太早打livenessProbe, readinessProbe導致高失敗率(因為啟動很久, 太早打一定都失敗的), 所以用這個probe來確認容器成功後才真的去實施那兩個探測</p><p>容器啟動很久其實不是一個很好的practice, 所以這個其實也是萬不得以才在用, 如果啟動時間不長的話, 為probe設定initialDelaySeconds 就已經很足夠了</p><h2 id=誰去打這些probe的>誰去打這些Probe的?</h2><p>一個比較錯誤的想像是, Kubernetes在某個地方, control plane或那裡有個服務去打所有的probe, 其實不是, 這樣它會累死</p><p>其實是由每個node的kubelet來負責, 當被加入一個Pod時, kubelet就會為這些probe每個都起一個go routine來根據設定的規則做檢查(感覺這設計沒太好, 會起不少go routine)</p><p>可以參考kubelet的<a href=https://github.com/kubernetes/kubernetes/blob/7581ae812327fc8218204f678143a6f116cad931/pkg/kubelet/prober/prober_manager.go#L169-L213>實做細節</a></p><p>這樣其實比較合理啦, 每個node的kubelet就顧自己家後院就好</p><h2 id=spring-boot-acuator的kubernetes-probes>Spring boot acuator的Kubernetes Probes</h2><p>Spring boot acuator預設的health endpoint是<code>/actuator/health</code>, 但這其實不好一體適用於liveness和readiness</p><p>Spring boot要用<code>/actuator/health/liveness</code>在livenessProbe而<code>/actuator/health/readiness</code>在readinessProbe, 可以參考<a href=https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/production-ready-features.html#production-ready-kubernetes-probes>這篇&mldr;.</a></p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2023-01-02 21:45:11 +0800 +0800"><a href=/Zai-K8sshang-Jia-She-Mian-Zookeeperde-Kafka/>Jan 2, 2023</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~5 minutes</span></div><h1 class=entry-title><a href=/Zai-K8sshang-Jia-She-Mian-Zookeeperde-Kafka/ rel=bookmark title=在k8s上架設免zookeeper的Kafka itemprop=url>在k8s上架設免zookeeper的Kafka</a></h1></header><div class=entry-content><p>架設Kafka一個稍稍討厭的點就是先架好Zookeeper, 在Kafka 2.8 (2021/4發布)之後, 支援了以自家的KRaft實現的Quorum controller, 這就可以不用再依賴zookeeper了, Confluent<a href=https://developer.confluent.io/learn/kraft/>這篇文章</a>有簡單的介紹一下Quorum controller是怎運作的</p><p>在我前面<a href=https://blog.jln.co/dapr-raw-payload-pub-sub/>這篇</a>有提到, 如何用docker跑無zookeeper的Kafka:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -it --name kafka-zkless -p 9092:9092 -e LOG_DIR<span style=color:#f92672>=</span>/tmp/logs quay.io/strimzi/kafka:latest-kafka-2.8.1-amd64 /bin/sh -c <span style=color:#e6db74>&#39;export CLUSTER_ID=$(bin/kafka-storage.sh random-uuid) &amp;&amp; bin/kafka-storage.sh format -t $CLUSTER_ID -c config/kraft/server.properties &amp;&amp; bin/kafka-server-start.sh config/kraft/server.properties&#39;</span>
</span></span></code></pre></div><p>那如果要架設在K8S上, 可以怎麼做呢? 原本的Kafka需要依賴zookeeper, 加上Kafka的eco system其實蠻多東西的, 一般也不會光只用Kafka本身而已, Kafka Bridge, Kafka connect, schema registry, 進階一點就Kafka stream, KSQL, 規模大一點還需要用上Cruise control, Mirror Maker, 所以用Operator來架設可能會比單純寫manifest, helm chart來的好用, 而比較常見(有名的?)Kafka Operator大致上有這三個(就我知道的啦):</p><ol><li><a href=https://docs.confluent.io/5.5.1/installation/operator/index.html>Confluent Operator</a>, 由Confluent這家公司發布的, 由於Confluent這家公司的背景(<a href=https://docs.confluent.io/5.5.1/installation/operator/index.html>https://docs.confluent.io/5.5.1/installation/operator/index.html</a>), Kafka雖是Open source但就是他們家的產品, 所以這個也算是官方出品的Operator, 但這個功能上比較起來稍弱, 而且並沒啥更新, 當然也就還沒看到KRaft相關的支援</li><li><a href=https://banzaicloud.com/docs/supertubes/kafka-operator/>KOperator</a>, <a href=https://banzaicloud.com/>萬歲雲(Bonzai Cloud)</a>出品, 由於Bonzai Cloud目前是Cisco的, 所以這個也可以算大公司出品(?), 我自己是還沒用過, 但看架構, 預設就會架起Cruise control跟Prometheus, 感覺架構上考量是比較完整的, 另外就是也考量到部屬到Istio mesh的部分, 用Envoy來做external LB, 以及用等等, 另外一個值得一提的是Kafka這種Stateful application, 它卻並不是採用Statefulset來部署(它的文件有提到<code>All Kafka on Kubernetes operators use StatefulSet to create a Kafka Cluster</code>, 但事實是後來Strimzi也採用一樣的策略了), 但一樣的, 也還沒有支援KRaft</li><li><a href=https://strimzi.io/>Strimzi Operator</a>, 這應該算蠻廣泛被利用的一個Operator, 支援豐富, 更新迅速, 也是可以支援Cruise control (不一定要開), 基本該支援的, 應該也都差不多了, 而且從0.29就支援了KRaft, 不過這個Operator基本消費的記憶體就需要到300MB了</li></ol><p>總和以上, 看起來如果要在K8S上玩KRaft的話, Strimzi是一個比較適合的選擇</p><h2 id=安裝strimzi-operator>安裝Strimzi operator</h2><p>用以下指令安裝:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace kafka
</span></span><span style=display:flex><span>kubectl create -f <span style=color:#e6db74>&#39;https://strimzi.io/install/latest?namespace=kafka&#39;</span> -n kafka
</span></span></code></pre></div><p>這除了會建立strimzi-cluster-operator這個Deployment, 也會建立相關的ClusterRoles, ClusterRoleBindings, 和相關的CRD, 所以要先確定你有權限建立這些(尤其是Cluster level的), 其實相當簡單</p><p>另外, 用以下的manifest就會幫你建立好一個Kafka Cluster</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kafka.strimzi.io/v1beta2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Kafka</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-cluster</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>kafka</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>version</span>: <span style=color:#ae81ff>3.3.1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>listeners</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>plain</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>9092</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>type</span>: <span style=color:#ae81ff>internal</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>tls</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>tls</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>9093</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>type</span>: <span style=color:#ae81ff>internal</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>tls</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>offsets.topic.replication.factor</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>transaction.state.log.replication.factor</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>transaction.state.log.min.isr</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>default.replication.factor</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>min.insync.replicas</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>inter.broker.protocol.version</span>: <span style=color:#e6db74>&#34;3.3&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>storage</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ephemeral</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>zookeeper</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>storage</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ephemeral</span>
</span></span></code></pre></div><p>這會建立一個replica數量為3的Kafka cluster,以及對應的Zookeeper, 這邊的Storage type為ephemeral, 這表示它會用emptyDir當Volume, 如果你有相對應的PVC, 也可以把這替換掉</p><p>這邊還是會幫你建立出zookeeper, 那如何能擺脫zookeeper呢?</p><h2 id=打開實驗性功能>打開實驗性功能</h2><p>截至這邊文章寫的時間的版本(0.32), KRaft還是一個實驗性功能, 要以環境變數打開, 如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl set env deployments/strimzi-cluster-operator STRIMZI_FEATURE_GATES<span style=color:#f92672>=</span>+UseKRaft -n kafka
</span></span></code></pre></div><p>strimzi是靠STRIMZI_FEATURE_GATES來當作feature toggle, 在0.32只有一個實驗性功能的開關, 那就是<code>UseKRaft</code>, 上面那行指令就可以把這功能打開</p><p>用上面一模一樣的Manfest(Zookeeper那段要留著, 雖然沒用, 但在這版本還是必須), 就可以開出一個不依賴zookeeper的kafka cluster了, 以下是整個操作過程:</p><p><a href=https://asciinema.org/a/nibWve6U2E94pn1ljcNx6vscC><img src=https://asciinema.org/a/nibWve6U2E94pn1ljcNx6vscC.svg alt=asciicast></a></p><p>這邊你可能會發現, 我是用一個strimzipotset的資源來確認是否Kafka有沒正確被開成功, 你如果再去看Replica set, Stateful set, 你會發現找不到Kafka相關的, Strimzi其實就是靠自己的controller來管理Kafka的pods</p><p>你也可以用 <code>kubectl get kafkas -n kafka</code>來確認kafka這namespace下的kafka cluster的狀況</p><p>這個Manifest其實我拿掉了EntityOperator的部分, 是因為KRaft功能目前還沒支援TopicOperator, 沒拿掉會報錯</p><h2 id=是該拋棄zookeeper了嗎>是該拋棄Zookeeper了嗎?</h2><p>KRaft相對很新, 以三大有名的Kafka Operator來說, 目前也只有Strimzi有支援, 而且才剛開始, 實務上來說, 以功能, 穩定性或許應該還不是時候在production廣泛使用, 真要用, 還是多測試一下再說吧, 短時間還是跟zookeeper做做好朋友</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2022-12-10 02:15:17 +0800 +0800"><a href=/Ge-Ke-Neng-Rang-Mongodbzai-K8sxia-Bei-Oom_killde-Wen-Ti/>Dec 10, 2022</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~3 minutes</span></div><h1 class=entry-title><a href=/Ge-Ke-Neng-Rang-Mongodbzai-K8sxia-Bei-Oom_killde-Wen-Ti/ rel=bookmark title=一個可能讓Mongodb在k8s下被OOM_KILL的問題 itemprop=url>一個可能讓Mongodb在k8s下被OOM_KILL的問題</a></h1></header><div class=entry-content><p>做了些實驗, 紀錄一下, 剛好寫這篇時巴西也被幹掉了, 也記錄一下 XD</p><p>這個問題其實要滿足以下條件才可能發生:</p><ul><li>MongoDB版本在 4.4.14, 5.3.0, 5.0.7, 4.2.20 之前, 這算是一個Mongodb在2022一月才fix的一個bug, 所以比這幾版舊是有可能的</li><li>MongoDB instance在K8S上有設memory limit (且這limit要小於host node memory的一半?)</li><li>K8S所在的Host OS 的cgroup版本為V2, 可以<a href=https://github.com/opencontainers/runc/blob/main/docs/cgroup-v2.md>參考這文件</a>, Ubuntu 21.10, Fedora 31之後都開啟V2了, 不過如果你用的是WSL2, 由於WSL2的Kenel還是V1, 是試不出這問題的 (我是找了台Fedora來試)</li></ul><h3 id=問題是甚麼>問題是甚麼?</h3><p>查這問題的起因當然是碰到Mongodb被OOM Kill, 後來發現好像這也算蠻常踩到的坑, 只是好像沒人寫出完整可能性</p><p>碰到被OOM Kill第一個會思考的是, 他為何要那麼多記憶體?要給他多少才夠? 另外一個是, 由於是發生在container, 跑在K8S上, 一個疑問是, 那MongoDB是否會遵守設給他的resource limit? 還是他會當node所有記憶體都是他可用的?</p><h3 id=有沒有哪裡可疑的>有沒有哪裡可疑的?</h3><p>有哪些東西會吃記憶體? 連線會, index會, 但其實其中一個比較可疑的是給Wired Tiger的cache, 根據<a href=https://www.mongodb.com/docs/manual/core/wiredtiger/>這份文件</a>, Wired Tiger的cache會用掉</p><ul><li>50% 的(總記憶體 - 1GB) 或是</li><li>256MB</li></ul><p>也就是至少256MB, 然後如果你有64G記憶體, 他就會用掉最多 (64-1)/2, 到這聽起來好像沒啥問題, 只用一半還不至於有撐爆的問題, 會不會是其他的地方?</p><p>但另一個問題是, 直接裝在單機沒問題, 如果是跑在K8S上的容器, Memory limit我們是給在K8S上, MongoDB到底會以memory limit當總記憶體大小還是以整個node全部可用的記憶體計算?</p><p>其實根據文件的補充說明, 它是有考慮到的, 它會以<a href=https://www.mongodb.com/docs/manual/reference/command/hostInfo/#mongodb-data-hostInfo.system.memLimitMB>hostInfo.system.memLimitMB</a> 來計算</p><p><code>In some instances, such as when running in a container, the database can have memory constraints that are lower than the total system memory. In such instances, this memory limit, rather than the total system memory, is used as the maximum RAM available.</code></p><p>而它這資訊是透過cgroup去抓的, K8S也是用cgroup做資源管理的, 所以這值會等於你設定的limit</p><p>我第一次在WSL下測試, 把memory limit設為2Gi, <a href=https://www.mongodb.com/docs/manual/reference/command/hostInfo/#mongodb-data-hostInfo.system.memLimitMB>hostInfo.system.memLimitMB</a> 也的確是這個值(用mongo client下<code>db.hostInfo()</code>即可查詢)</p><p>那看來應該沒問題呀, 問題在哪?</p><p>後來查到一個bug : <a href=https://jira.mongodb.org/browse/SERVER-60412>https://jira.mongodb.org/browse/SERVER-60412</a>, 原來cgroup v1, v2抓這些資訊的位置是不同的, 所以導致舊版的會有抓不正確的狀況</p><p>看到這就來做個實驗, 找了台有開啟v2的fedora (with podman), 跑了k3s, 在這k3s上分別跑了4.4.13, 4.4.15兩個版本去做測試, memory limit都設為2Gi, 用<code>db.hostInfo()</code>查詢memLimitMB得到下面結果:</p><h4 id=4413>4.4.13</h4><p><img src=/images/posts/mongo4.13.mem.png alt></p><h4 id=4415>4.4.15</h4><p><img src=/images/posts/mongo4.15.mem.png alt></p><p>Bingo! 4.4.13果然抓到的memLimitMB是整個node的記憶體大小而非limit, 這樣如果node的記憶體大小遠大於limit, Wired Tiger cache是有可能用超過limit的</p><p>當然, 這只是其中一種可能性, 不見得一定都是這情形, 但碰到這類狀況, 這的確是可以考慮查的一個方向</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2022-11-13 13:11:27 +0800 +0800"><a href=/Shi-Yong-Dapr-Input-Output-Bindinglian-Jie-Kafka/>Nov 13, 2022</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~4 minutes</span></div><h1 class=entry-title><a href=/Shi-Yong-Dapr-Input-Output-Bindinglian-Jie-Kafka/ rel=bookmark title="使用Dapr Input/Output Binding連接Kafka" itemprop=url>使用Dapr Input/Output Binding連接Kafka</a></h1></header><div class=entry-content><p>在Dapr元件有一種叫做Binding的元件(component)讓你的app跟外部系統做一個連結的, 這元件可分為兩類:</p><ol><li>Input BIndings: 用來接受外部事件的觸發,像是Webhook, 從Queue來的events, 甚至是人家新發的Tweets, 應該都可以歸為這一類</li><li>Ouput Bindings: 呼叫外部系統的動作,命名為Outpiut其實會讓人誤以為是資料的輸出,但其實,他不只可以用在資料輸出,呼叫外部系統的動作都可以包含在內, 舉個例子, <a href=https://github.com/dapr/components-contrib/tree/master/bindings/graphql>GraphQL 的Output binding</a>定義了兩個操作(Operations), 一個是QueryOperation, 一個是MutationOperation, 熟悉GraphQL的應該知道,MutationOperation一般才是應用在資料操作,而Query感覺就跟輸出比較無關了</li></ol><p>一開始我也有點搞不清楚這個模式目的在做啥的, 要接受事件觸發,我們有pub sub了,而state store本身就用在資料輸出, 感覺的確有點重複,但由上述兩點來看,其實Binding定義的範圍廣泛多了,它並不特定限制在Queue或是資料庫</p><p>但有個東西同時支援了Pub sub, input binding, output binding, 一開始我是看Kafka這應用,才讓我覺得有點錯亂,<a href=dapr-raw-payload-pub-sub>前一篇</a>有講過了怎實作Subscriber, 這邊來比較一下, 利用Input binding的話,會有什麼不一樣?</p><h3 id=建立binding元件>建立Binding元件</h3><p><img src=/post/images/55875EA9-6C5C-48BB-8289-FF95B5CB5409.jpeg alt></p><p>要用Kafka來觸發我們服務(如上圖),跟寫Subscriber一樣,我們需要在<code>~/.dapr/components</code>裡先建立好元件, 假設我們新增一個<code>kafka-binding.yaml</code>, 內容如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>dapr.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Component</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kafka-binding</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>bindings.kafka</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>version</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>brokers</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#ae81ff>localhost:9092</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>topics</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#ae81ff>mytopic</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>consumerGroup</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#ae81ff>group1</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>publishTopic</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#ae81ff>mytopic</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>authRequired</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;false&#34;</span>
</span></span></code></pre></div><p>上面這個其實已經是定義好input和output binding了,topics定義的是input binding要聽取事件的topic, 而publishTopic定義的則是Output binding要輸出資料的目標</p><h3 id=實作input-binding>實作Input binding</h3><p>跟實做subscriber差不多, Input binding也是實作一個webhook讓Dapr打進來而已, 這邊假設Kafka會收到的資料會是一個數字</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;github.com/gin-gonic/gin&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dataBinding</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Bind</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>data</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>AbortWithStatus</span>(<span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Status</span>(<span style=color:#ae81ff>200</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Default</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>POST</span>(<span style=color:#e6db74>&#34;/kafka-binding&#34;</span>, <span style=color:#a6e22e>dataBinding</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>OPTIONS</span>(<span style=color:#e6db74>&#34;/kafka-binding&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Status</span>(<span style=color:#ae81ff>200</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:6003&#34;</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這邊幾個重點:</p><ol><li>endpoint path跟你的binding名稱一樣, 當然這可以在元件設定那邊改</li><li>OPTIONS有點像是讓Dapr確認你有沒支援這個binding的health endpoint, 在程式一開始跑就會被call, 這邊只要回OK, 其實都好</li><li>跟pub sub不一樣的是, 這邊會收到的格式不一定會是cloudevent, 除非publisher那邊過來的就是cloudevent, 因此, tracing應該是追蹤不到才是</li></ol><h3 id=實做output-binding>實做Output binding</h3><p>那如何實作跟剛剛的Input binding匹配的Output binding呢? 範例如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;context&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;math/rand&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dapr</span> <span style=color:#e6db74>&#34;github.com/dapr/go-sdk/client&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BINDING_NAME</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;kafka-binding&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BINDING_OPERATION</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;create&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Seed</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>UnixMicro</span>())
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dataId</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>1000</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dapr</span>.<span style=color:#a6e22e>NewClient</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>in</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>dapr</span>.<span style=color:#a6e22e>InvokeBindingRequest</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#a6e22e>BINDING_NAME</span>, <span style=color:#a6e22e>Operation</span>: <span style=color:#a6e22e>BINDING_OPERATION</span>, <span style=color:#a6e22e>Data</span>: []byte(<span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>dataId</span>))}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>InvokeOutputBinding</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>in</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Sending message: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>dataId</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這邊重點在於:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>in</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>dapr</span>.<span style=color:#a6e22e>InvokeBindingRequest</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#a6e22e>BINDING_NAME</span>, <span style=color:#a6e22e>Operation</span>: <span style=color:#a6e22e>BINDING_OPERATION</span>, <span style=color:#a6e22e>Data</span>: []byte(<span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>dataId</span>))}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>InvokeOutputBinding</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>in</span>)
</span></span></code></pre></div><p>雖說是"Output" binding, 但這邊用的名字是"Invoke", 跟Output沒啥相關, Operation則是元件訂的, Kafka binding只定義一個"create", 就是讓你送訊息用的, Data則是要傳送的資料, 以Byte array表示</p><h3 id=用subscriber接收output-binding來的事件>用subscriber接收output binding來的事件</h3><p>這邊就不用多作解釋了, 從前面不難發現, 它接的就是raw payload, 這部分可以參考 <a href=dapr-raw-payload-pub-sub>前一篇</a></p><p>那啥時該用哪一種呢? 以Kafka這範例來說, 我是認為如果publisher跟subscriber都是自己實做的話, 應該是要選用pub sub, 用cloud events的話, 可以享受到distributed tracing帶來的好處, 如果不是, 差異應該不大, 都蠻簡單實作的</p></div></article><div class=pagination><ul class=inline-list><li><strong class=current-page>1</strong></li><li><a href=/post/page/2/>2</a></li><li><a href=/post/page/3/>3</a></li><li><a href=/post/page/4/>4</a></li><li><a href=/post/page/5/>5</a></li><li><a href=/post/page/6/>6</a></li><li><a href=/post/page/7/>7</a></li><li><a href=/post/page/8/>8</a></li><li><a href=/post/page/9/>9</a></li><li><a href=/post/page/10/>10</a></li><li><a href=/post/page/11/>11</a></li><li><a href=/post/page/12/>12</a></li><li><a href=/post/page/13/>13</a></li><li><a href=/post/page/14/>14</a></li><li><a href=/post/page/15/>15</a></li><li><a href=/post/page/16/>16</a></li><li><a href=/post/page/17/>17</a></li><li><a href=/post/page/18/>18</a></li><li><a href=/post/page/19/>19</a></li><li><a href=/post/page/20/>20</a></li><li><a href=/post/page/21/>21</a></li><li><a href=/post/page/22/>22</a></li><li><a href=/post/page/23/>23</a></li><li><a href=/post/page/24/>24</a></li><li><a href=/post/page/25/>25</a></li><li><a href=/post/page/26/>26</a></li><li><a href=/post/page/27/>27</a></li><li><a href=/post/page/28/>28</a></li><li><a href=/post/page/29/>29</a></li><li><a href=/post/page/30/>30</a></li><li><a href=/post/page/31/>31</a></li><li><a href=/post/page/32/>32</a></li><li><a href=/post/page/33/>33</a></li><li><a href=/post/page/34/>34</a></li><li><a href=/post/page/35/>35</a></li><li><a href=/post/page/36/>36</a></li><li><a href=/post/page/37/>37</a></li><li><a href=/post/page/38/>38</a></li><li><a href=/post/page/39/>39</a></li><li><a href=/post/page/40/>40</a></li><li><a href=/post/page/41/>41</a></li><li><a href=/post/page/42/>42</a></li><li><a href=/post/page/43/>43</a></li><li><a href=/post/page/44/>44</a></li><li><a href=/post/page/45/>45</a></li><li><a href=/post/page/46/>46</a></li><li><a href=/post/page/47/>47</a></li><li><a href=/post/page/48/>48</a></li><li><a href=/post/page/49/>49</a></li><li><a href=/post/page/50/>50</a></li><li><a href=/post/page/51/>51</a></li><li><a href=/post/page/52/>52</a></li><li><a href=/post/page/53/>53</a></li><li><a href=/post/page/54/>54</a></li><li><a href=/post/page/55/>55</a></li><li><a href=/post/page/56/>56</a></li><li><a href=/post/page/57/>57</a></li><li><a href=/post/page/58/>58</a></li><li><a href=/post/page/59/>59</a></li><li><a href=/post/page/60/>60</a></li><li><a href=/post/page/61/>61</a></li><li><a href=/post/page/62/>62</a></li><li><a href=/post/page/63/>63</a></li><li><a href=/post/page/64/>64</a></li><li><a href=/post/page/65/>65</a></li><li><a href=/post/page/66/>66</a></li><li><a href=/post/page/67/>67</a></li><li><a href=/post/page/68/>68</a></li><li><a href=/post/page/69/>69</a></li><li><a href=/post/page/70/>70</a></li><li><a href=/post/page/71/>71</a></li><li><a href=/post/page/72/>72</a></li><li><a href=/post/page/73/>73</a></li><li><a href=/post/page/74/>74</a></li><li><a href=/post/page/75/>75</a></li><li><a href=/post/page/76/>76</a></li><li><a href=/post/page/77/>77</a></li><li><a href=/post/page/2/ class=btn>Next</a></li></ul></div></div><div class=footer-wrapper><footer role=contentinfo><span>Powered by <a href=https://gohugo.io/ rel=nofollow>Hugo</a> using the <a href=https://github.com/dldx/hpstr-hugo-theme rel=nofollow>HPSTR theme</a>.</span></footer></div><script src=//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js></script>
<script src=https://kit.fontawesome.com/872a53b461.js crossorigin=anonymous></script>
<script>window.jQuery||document.write('<script src="/js/vendor/jquery-1.9.1.min.js"><\/script>')</script><script src=/js/scripts.min.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-79243751-1","auto"),ga("send","pageview"))</script><div id=fb-root></div><script async defer crossorigin=anonymous src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v7.0&appId=293999444006555&autoLogAppEvents=1" nonce=geZSUIUh></script></body></html>