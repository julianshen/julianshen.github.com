<!doctype html><!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=en><![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang=en><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang=en><![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en><!--<![endif]-->
<head>
<meta charset=utf-8>
<title>使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc &#8211; Le murmure de Julian</title>
<meta name=description content>
<meta property="og:title" content="使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc">
<meta property="og:description" content="在離職前一周研究的一個小題目, 說小其實也蠻難搞的, 搞到這兩天重新看, 才釐清完整做法 難搞的原因有幾個, 雖然OpenTelemetry有支援gR">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jln.co/%E4%BD%BF%E7%94%A8-OpenTelemetry-%E8%B7%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%BD%E8%B9%A4-Thrift-Rpc/"><meta property="og:image" content="https://og.jln.co/jlns1/5L2_55SoIE9wZW4gVGVsZW1ldHJ5IOi3qOS4jeWQjOW5s-WPsOi_vei5pCBUaHJpZnQgUnBj"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-08-12T00:35:55+08:00">
<meta property="article:modified_time" content="2021-08-12T00:35:55+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://og.jln.co/jlns1/5L2_55SoIE9wZW4gVGVsZW1ldHJ5IOi3qOS4jeWQjOW5s-WPsOi_vei5pCBUaHJpZnQgUnBj">
<meta name=twitter:title content="使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc">
<meta name=twitter:description content="在離職前一周研究的一個小題目, 說小其實也蠻難搞的, 搞到這兩天重新看, 才釐清完整做法 難搞的原因有幾個, 雖然OpenTelemetry有支援gR">
<link rel=canonical href=https://blog.jln.co/%E4%BD%BF%E7%94%A8-OpenTelemetry-%E8%B7%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%BD%E8%B9%A4-Thrift-Rpc/>
<meta name=HandheldFriendly content="True">
<meta name=MobileOptimized content="320">
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href=/css/main.css>
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel=stylesheet type=text/css>
<meta http-equiv=cleartype content="on">
<meta name=generator content="Hugo 0.87.0">
<script src=/js/vendor/modernizr-2.6.2.custom.min.js></script>
<script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script>
<link rel="shortcut icon" href=/favicon.png>
</head>
<body id=post>
<nav id=dl-menu class=dl-menuwrapper role=navigation style=display:inline-block>
<button class=dl-trigger>Open Menu</button>
<ul class=dl-menu>
<li><a href=/>Home</a></li>
<li>
<a href=#>About</a>
<ul class=dl-submenu>
<li>
<img src=/images/avatar.png alt="Julian Shen's photo" class=author-photo>
<h4>Julian Shen</h4>
<p>Softward developer</p>
</li>
<li>
<a href=mailto:julianshen22@gmail.com><i class="fa fa-fw fa-envelope"></i> Email</a>
</li>
<li>
<a href=https://linkedin.com/in/julianshen><i class="fa fa-fw fa-linkedin"></i> LinkedIn</a>
</li>
<li>
<a href=https://github.com/julianshen><i class="fa fa-fw fa-github"></i> GitHub</a>
</li>
<li>
<a href=https://instagram.com/julianshen><i class="fa fa-fw fa-instagram"></i> Instagram</a>
</li>
</ul>
</li>
<li>
<a href=#>Posts</a>
<ul class=dl-submenu>
<li><a href=/post/>All Posts</a></li>
<li><a href=/tags/>All Tags</a></li>
</ul>
</li>
<li><a href=/></a></li>
</ul>
</nav>
<div id=main role=main>
<article class=hentry>
<header class=header-title>
<div class=header-title-wrap>
<h1 class=entry-title><a href=/%E4%BD%BF%E7%94%A8-OpenTelemetry-%E8%B7%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%BD%E8%B9%A4-Thrift-Rpc/ rel=bookmark title="使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc">使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc</a></h1>
<h2><span class="entry-date date published"><time datetime="2021-08-12 00:35:55 +0800 +0800">August 12, 2021</time></span></h2>
<p class=entry-reading-time>
<i class="fa fa-clock-o"></i>
Reading time ~12 minutes
</p>
</div>
</header>
<div class=entry-content>
<p>在離職前一周研究的一個小題目, 說小其實也蠻難搞的, 搞到這兩天重新看, 才釐清完整做法</p>
<p>難搞的原因有幾個, 雖然<a href=https://opentelemetry.io/>OpenTelemetry</a>有支援<a href=https://grpc.io/>gRPC</a>, 但對於 <a href=http://thrift.apache.org/>Thrift</a> 就沒人做相關的支援了, 再來就是系統環境跨了nodejs和<a href=https://twitter.github.io/finagle/>Finagle</a>/Scala兩種平台, Thrift 是用在這兩者之間的溝通, Finagle雖是有支援<a href=https://zipkin.io/>ZipKin</a><a href=https://twitter.github.io/finagle/guide/Tracing.html>做分散式追蹤</a>, 但那僅限於Finagle client呼叫Finagle server的部分才有支援在這之間傳遞追蹤資訊, 跨nodejs (client) 到 Finagle (server), 這邊也一樣找不到啥資訊</p>
<p>所以這邊主要會想做到的:</p>
<ol>
<li>自動插入追蹤的程式碼</li>
<li>在 Thrift client/server 間傳遞追蹤資訊 (client/server不同平台)</li>
</ol>
<p>大致上的原理有做過些小實驗, 確定應該可行, 只是懶得把整套完整做好就是了</p>
<h2 id=分散式追蹤-distributed-tracinghttpslightstepcomdistributed-tracing><a href=https://lightstep.com/distributed-tracing/>分散式追蹤 Distributed Tracing</a></h2>
<p>在大型的分散式系統, 一個從使用者端來的request通常都會被分發到不同的系統去做處理, 尤其現在大多流行微服務(Micro services)架構, 這種狀況相當的常見, 當問題發生的時候, 到底甚麼時間點在哪個系統, 碰到甚麼事, 要追查原因便得從這麼多系統分散且看不出關聯性的log去想辦法分析出來, 因此導入分散式追蹤, 就是為了解決這問題</p>
<p>最早出現應該是Google內部使用的Dapper, 也有發表相關的<a href=https://static.googleusercontent.com/media/research.google.com/en//archive/papers/dapper-2010-1.pdf>論文</a>, 開源的部分, 早期又有Twitter的<a href=https://zipkin.io/>ZipKin</a>和Uber的<a href=https://www.jaegertracing.io/>Jaeger</a>, 前面有提到的<a href=https://twitter.github.io/finagle/>Finagle</a>, 由於也是Twitter開源出來的應用程式框架, 所以<a href=https://twitter.github.io/finagle/>Finagle</a>出廠就支援<a href=https://zipkin.io/>ZipKin</a>也是理所當然的</p>
<p>後來又出現想要大一統的<a href=https://opentracing.io/>OpenTracing</a>和<a href=https://opencensus.io/>OpenCensus</a>, 這兩個後來又被大一統到這邊所要提到的<a href=https://opentelemetry.io/>OpenTelemetry</a></p>
<p>做Distributed Tracing雖然對追問題會有幫助, 但要導入並不見的容易, 先是要在所有要追蹤的插入追蹤程式碼, 對於既有系統的改動幅度自是不小, 此外, 早期, 不管是<a href=https://zipkin.io/>ZipKin</a>和Uber的<a href=https://www.jaegertracing.io/>Jaeger</a>還是<a href=https://www.jaegertracing.io/>Jaeger</a>考量的主要還是REST API的架構, REST是透過HTTP傳輸的, 因此在設計上, 就可以透過HTTP header帶追蹤相關資訊, 但在一個複雜的分散式系統, 可能包含不同的通訊協定, 像是REST, GraphQL, gRPC, Thrift, 或是呼叫資料庫之類的, 不見得都是透過HTTP, 那怎麼傳遞追蹤資訊就是個問題, 跨系統間如果無法分享追蹤資訊, 那也是白搭</p>
<h2 id=opentelemetryhttpsopentelemetryio><a href=https://opentelemetry.io/>OpenTelemetry</a></h2>
<p><a href=https://opentelemetry.io/>OpenTelemetry</a>其實也不是只有支援Distributed Tracing, 它能處理的資料型態, 主要就有下面這幾種:</p>
<ol>
<li>Traces</li>
<li>Metrics</li>
<li>Logs</li>
</ol>
<p>也就是說除了追蹤資訊, 它也囊括了系統狀態跟Logs, 另外也支援很多不同語言, 算是野心蠻大的, 這邊來看一下它的架構:</p>
<p><a href=https://raw.github.com/open-telemetry/opentelemetry.io/main/iconography/Reference_Architecture.svg></a></p>
<p>主要它包含了兩部分, 一個是各程式語言使用的程式庫 - OT Library, 另一個是蒐集資訊的Collector, 而Collector是這樣的:</p>
<p><a href=https://raw.github.com/open-telemetry/opentelemetry.io/main/iconography/Otel_Collector.svg></a></p>
<p>Collector包含了Receiver, Processor, Exporter, 這架構讓它有能力相容/支援不同的系統, 所以像是Finagle這種本來就有支援ZipKin的, 其實只要把原本倒到ZipKin的資料轉倒到OpenTelemetry的Collector就好, 這邊算是好解決, 如果系統是跑在K8S這類的環境上的話, 也可以考慮把Collector
當成sidecar來佈署</p>
<p>而各程式語言的程式庫的部分, 方便的是在某些程式語言有支援所謂的auto instrumentation, 針對有支援的程式庫或是框架, 可以在不寫任何程式碼或是寫少少的程式碼, 就可以達到分散式追蹤的目的(聽來有點玄), 像是Java就<a href=https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks>支援了這些</a>(請參考連結), 而<a href=https://github.com/open-telemetry/opentelemetry-js-contrib>Javascript有這些</a>(請參考連結)</p>
<p>但畢竟沒有甚麼是萬能的, 沒支援的還是得靠自己手動插追蹤的程式碼, 或是想辦法支援, 像是這篇正題的部分, 這邊想要追蹤從nodejs呼叫Finagle的部分, 就沒辦法使用現成的 (實際狀況更複雜, nodejs本身是graphql server, Finagle server又可能呼叫ElasticSearch或Kafka, 如果想全部串起來, 不算小, 這邊主要針對 nodejs &lt;-> Finagle部分)</p>
<h2 id=在nodejs下用opentelemetry做tracing>在Node.JS下用OpenTelemetry做Tracing</h2>
<p>基本使用上其實相當簡單, 可以參考這個<a href=https://opentelemetry.io/docs/js/getting_started/nodejs/>連結</a>, 先用一個小範例來解釋:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>HttpInstrumentation</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation-http&#39;</span>);
<span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>GrpcInstrumentation</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation-grpc&#39;</span>);
<span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>ExpressInstrumentation</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation-express&#39;</span>);
<span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>ConsoleSpanExporter</span>, <span style=color:#a6e22e>SimpleSpanProcessor</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/tracing&#39;</span>);
<span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>NodeTracerProvider</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/node&#39;</span>);
<span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>registerInstrumentations</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation&#39;</span>);

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>provider</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NodeTracerProvider</span>();

<span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>addSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SimpleSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ConsoleSpanExporter</span>()));
<span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>register</span>();

<span style=color:#a6e22e>registerInstrumentations</span>({
  <span style=color:#a6e22e>instrumentations</span><span style=color:#f92672>:</span> [
      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HttpInstrumentation</span>(), 
      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>GrpcInstrumentation</span>(),
      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ExpressInstrumentation</span>()
      ],
});
</code></pre></div><p>以這範例來說, 它打開了支援http, grpc, express等程式庫的auto instrumentation, 亦即在你的程式中如果有用到這幾個程式庫, 它會自動加上對應的追蹤程式碼, 你不用額外做任何事, 從client到server都處理好, 或是你也可以像文件中用:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// This will automatically enable all instrumentations
</span><span style=color:#75715e></span><span style=color:#a6e22e>registerInstrumentations</span>({
  <span style=color:#a6e22e>instrumentations</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>getNodeAutoInstrumentations</span>()],
});
</code></pre></div><p><code>getNodeAutoInstrumentations()</code>包含了底下這幾種的資源:</p>
<ul>
<li><code>@opentelemetry/instrumentation-dns': DnsInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-express': ExpressInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-graphql': GraphQLInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-grpc': GrpcInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-http': HttpInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-ioredis': IORedisInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-koa': KoaInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-mongodb': MongoDBInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-mysql': MySQLInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-pg': PgInstrumentation</code></li>
<li><code>@opentelemetry/instrumentation-redis': RedisInstrumentation</code></li>
</ul>
<p>建議如果沒要追蹤這麼多東西的話, 還是一個個加就好, 畢竟資訊多雜訊也多</p>
<p>在這邊:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>provider</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NodeTracerProvider</span>();
<span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>addSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SimpleSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ConsoleSpanExporter</span>()));
</code></pre></div><p>這兩行是建立Trace Provider, 告訴它要用哪個Processor或哪個Exporter去處理追蹤資訊, 這跟前面提到的Collector的架構上大致類似, 這邊用的是Consle exporter,也就是追蹤資訊會被直接印在螢幕上, 如果想輸出到ZipKin或是Jaeger就用相對應的Exporter就可以了, 或者也可以用OTLP的Exporter直接輸出到OpenTelemetry的collector</p>
<p>但這是在有支援的狀況下, 如果沒有呢? 就得手動去插了, 看一下下面這範例:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>opentelemetry</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/api&#39;</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tracer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>opentelemetry</span>.<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>getTracer</span>(<span style=color:#e6db74>&#39;example-basic-tracer-node&#39;</span>);

<span style=color:#75715e>// Create a span. A span must be closed.
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>span</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tracer</span>.<span style=color:#a6e22e>startSpan</span>(<span style=color:#e6db74>&#39;main&#39;</span>);
<span style=color:#a6e22e>doWork</span>();
<span style=color:#75715e>// Be sure to end the span.
</span><span style=color:#75715e></span><span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>end</span>();
</code></pre></div><p>這是簡單追蹤一個程序的方法, 在這範例是<code>doWork()</code>, 這邊就可以追蹤從<code>startSpan</code>到<code>end</code>之間的耗費的時間了, 針對沒有支援auto instrumentation, 或是你想額外在你程式內追蹤些別的, 那就得用這種方式在需要追蹤的地方加入這些</p>
<p>很不幸的, 目前不管哪個語言, Java, Javascript, 都沒支援Thrift相關的, 所以如果要追蹤 Thrift, 可能就得是這樣, 除了可能需要改不少地方外, 插入這些code其實也不太好看啦 :p</p>
<h2 id=追蹤-thrift-rpc>追蹤 Thrift RPC</h2>
<p>Thrift算是一個有點歷史的RPC框架(framework)了, 雖然應該還有不少大公司像是Twitter, Facebook, LINE, LinkedIn還有在使用, 不過現在大家大部分應該是比較常用比較潮的gRPC, 比較少用Thrift了, 所以在OpenTelemetry這種新東西找不到支援應該也情有可原</p>
<p>為了比較好確認解決這問題的概念是怎樣, 這邊先把問題/架構先簡化如下:</p>
<ol>
<li>Thrift client: 跑在nodejs下, 以typescript開發</li>
<li>Thrift server: 跑在Twitter Finagle框架, 以scala開發 (事實上, 我也有實做一個go版本的server, 不過先不在這討論)</li>
</ol>
<p>所以這邊會需要知道的是:</p>
<ol>
<li>client呼叫每個Thrift call需要的時間</li>
<li>在server上每個call又對應哪些呼叫或花費</li>
</ol>
<p>用以下ZipKin這張圖來當範例, 就可以這樣一層層追蹤下去</p>
<p><img src=/images/posts/2021-08-12-11-43-50.png alt=ZipKin></p>
<p>Client部分雖然可以使用手工插入tracing相關的程式碼, 但當然還是做成自動的最好, 而且client必須要可以把相關的trace ID, span ID給傳遞到server, 要不然線索就會斷掉了</p>
<p>為了達到這目標, 首先我們先來看一下Thrift從Client到Server經過哪些地方:</p>
<p><img src=/images/posts/thrift.drawio.png alt=Thrift></p>
<p>從這圖看來, 可能可以插入追蹤碼的點可以是產生出來的Client code或是TProtocol的位置(為何?後面再提)</p>
<p>在前面我也寫了一篇"<a href=https://blog.jln.co/%E5%9C%A8nodejs%E4%BD%BF%E7%94%A8typescript%E5%91%BC%E5%8F%ABthrift-client/>在nodejs使用typescript呼叫thrift client</a>&ldquo;裡面有提到利用<code>thrift -r --gen js:ts smaple.thrift</code>來產生nodejs用的client code</p>
<p>以下面這個Thrift IDL來當範例:</p>
<pre><code>namespace java sample.thrift
#@namespace scala sample.thrift
namespace go rpc

service SampleService {
    string hello(1: i64 a, 2: i64 b)
    void hello2()
}
</code></pre><p>用<code>thrift -r --gen js:ts sample.thrift</code>就可以產生四個檔案, 分別是:</p>
<ol>
<li>sample_types.js</li>
<li>sample_types.d.ts</li>
<li>SampleService.js SampleService的定義</li>
<li>SampleService.d.ts SampleService的javascript實作(Client + Processor)</li>
</ol>
<p>再仔細去看SampleService.js, 以hello這個method為例, 你會發現在 <code>SampleServiceClient</code> 裡關於hello的部分有三部分:</p>
<ol>
<li><code>hello(a, b, callback)</code> 實際給程式呼叫的介面, 這邊回傳是個Promise</li>
<li><code>send_hello(a, b)</code> 會由hello去呼叫, 實際上負責傳遞呼叫的相關資訊</li>
<li><code>recv_hello(input,mtype,rseqid)</code> 當send_hello送出呼叫資訊到server後, Connection會等到Server回應後, 會呼叫 recv_functionname, 去處理回傳回來的資訊</li>
</ol>
<p>另外在 <code>send_hello</code> 的一開始會去呼叫 <code>output.writeMessageBegin('hello', Thrift.MessageType.CALL, this.seqid());</code> , 這邊的output是TProtocol, 在呼叫 <code>recv_hello</code> 之前則是會呼叫 <code>input.readMessageBegin()</code> 這邊也可以得到呼叫的method的資訊</p>
<p>由上面的線索看來, 可以插入追蹤程式碼可能的幾個點:</p>
<ol>
<li><code>hello(a, b, callback)</code> 的一開始到Promise結束</li>
<li><code>send_hello(a, b)</code>到<code>recv_hello(input,mtype,rseqid)</code>的結束</li>
<li><code>writeMessageBegin</code> 到 <code>readMessageBegin</code></li>
</ol>
<p>這邊問題在於 <code>hello</code>, <code>send_hello</code>, <code>recv_hello</code>都是由<code>thrift</code>這個指令產出的, 而<code>writeMessageBegin</code>, <code>readMessageBegin</code>則是在thrift的程式庫內</p>
<p>我們要怎樣在裡面插入追蹤的程式碼?或是有沒辦法做到auto instrumentation那樣?</p>
<h2 id=javascript-auto-instrumentation-in-opentelemetry>Javascript auto instrumentation in OpenTelemetry</h2>
<p>OpenTelemetry其實是有開放介面給大家去開發相關的auto instrumentation, 不過這一塊實在看得有點頭痛, 沒文件, 又不好懂, 我最後沒採用這方法實作, 但因為在這邊花了不少時間, 還是簡單的介紹一下</p>
<p>前面有提到的有許多auto instrumentation的實作, 都是被放到 <a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>opentelemetry-js-contrib/plugins/node</a>, 也就是說你可以用一樣的方法做出自己的auto instrumentation</p>
<p>其架構的原始碼可以參考<a href=https://github.com/open-telemetry/opentelemetry-js/tree/4a1f2e5fd441cc9c0359d6aaff1919d9c6672682/packages/opentelemetry-instrumentation>opentelemetry-js/packages/opentelemetry-instrumentation</a>, 至於如何去寫一個plugin則可以參考 <a href=https://reachmnadeem.wordpress.com/2021/02/22/opentelemetry-automatic-instrumentation-of-a-nodejs-library/>這篇</a></p>
<p>基本的plugin大致上像這樣:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>import</span> <span style=color:#66d9ef>type</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>mssql</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;mypackage&#39;</span>;
<span style=color:#66d9ef>import</span> {
    <span style=color:#a6e22e>InstrumentationBase</span>,
    <span style=color:#a6e22e>InstrumentationConfig</span>,
    <span style=color:#a6e22e>InstrumentationModuleDefinition</span>,
} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@opentelemetry/instrumentation&#39;</span>;
 
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>InstrumentationConfig</span> ;
 
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MYPlugin</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>InstrumentationBase</span>&lt;<span style=color:#f92672>typeof</span> <span style=color:#a6e22e>mypackage</span>&gt; {
       
    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>init</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>InstrumentationModuleDefinition</span>&lt;<span style=color:#f92672>any</span>&gt; <span style=color:#f92672>|</span> <span style=color:#a6e22e>InstrumentationModuleDefinition</span>&lt;<span style=color:#f92672>any</span>&gt;[] {
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Method not implemented.&#39;</span>);
    }
}
</code></pre></div><p>Plugin必須繼承自InstrumentationBase, 最好的範例應該是 <a href=https://github.com/open-telemetry/opentelemetry-js/blob/4a1f2e5fd441cc9c0359d6aaff1919d9c6672682/packages/opentelemetry-instrumentation-http/src/http.ts>http的instrumentation的實作</a>, 在這裏面, 你會看到像是:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_wrap</span>(
          <span style=color:#66d9ef>module</span><span style=color:#a6e22e>Exports</span>,
          <span style=color:#e6db74>&#39;request&#39;</span>,
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_getPatchOutgoingRequestFunction</span>(<span style=color:#e6db74>&#39;http&#39;</span>)
        );
</code></pre></div><p>這目的就是為了把原本的函數替換成包裝過有插追蹤碼的程式, 原理其實很容易理解, 而它是用了 <a href=https://github.com/othiym23/shimmer/>shimmer</a> 這個package, 來達到這個替換的目的, 實際上去看 <a href=https://github.com/othiym23/shimmer/>shimmer</a>, 也並不是一個很複雜的做法就是了</p>
<p>本來我是考慮寫一個plugin來處理Thrift client的部分, 原本的考量點是, 由於 <a href=https://github.com/othiym23/shimmer/>shimmer</a> 需要先知道method的名字才能替代, 所以 <code>hello</code>, <code>send_hello</code>, <code>recv_hello</code> 就不適合用來做包裝, 畢竟要做也是要做一個通用的, 不然試作後, 單純包裝 <code>hello</code> 其實算容易 (在呼叫原版本hello前先startSpan, 並把span.end包裝到回傳的Promise), 所以適合用在這邊的可能是包裝 <code>TProtocol.writeMessageBegin</code>, <code>TProtocol.readMessageBegin</code> ,不過這邊一直弄不成功, 可能也沒搞很懂instrumentation plugin, 後來又發現更簡便的做法就先放棄</p>
<h2 id=從-thift-generator-下手>從 thift generator 下手</h2>
<p>在用 <a href=https://github.com/othiym23/shimmer/>shimmer</a> 包裝 <code>hello</code> 時, 發現了一個問題, 由於我是用 typescript 而非javascript 在做這個實驗, typescript會去做型別檢查, 本來Javascript版本的 <code>hello</code> 的回傳是Promise, 但我在定義wrapped function的時候, 回傳型別設成
<code>Promise&lt;string></code> 則是會報錯, 結果實際上去看產生的程式碼:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>Int64</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>Int64</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>;
</code></pre></div><p>這完全是錯的, 也就是由Apache thrift這個工具產生的typescript是有問題的</p>
<p>想到在Scala中, 產生Thrift相關程式碼是用scrooge並不會去用官方Apache thrift的工具, typescript會不會也有像scrooge這工具? 結果就找到了<a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>creditkarma/thrift-typescript</a></p>
<p>這個專案也是蠻有趣的, 它是透過 <a href=https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API>Typescript compiler API</a>, 把Thrift IDL完全轉成typescript程式碼, 跟官方工具不同的地方是, 它產生的是純typecsript實做, 而非javascript實做搭配typescript定義, 因此產生的程式碼也好讀多了</p>
<p>所以我想, 何必一定糾結在auto instrumentation, 從code generator 去修改也是一個可行的做法, 要做到這件事, 那就要先看看, 我們預期它產生怎樣的程式碼, 於是我就去修改產生的程式碼來實驗, 像這樣:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Client</span> {
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>_seqid</span>: <span style=color:#66d9ef>number</span>;
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>_reqs</span><span style=color:#f92672>:</span> {
        [<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>number</span>]<span style=color:#f92672>:</span> (<span style=color:#a6e22e>err</span>: <span style=color:#66d9ef>Error</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>object</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>, <span style=color:#a6e22e>val?</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>;
    };
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>output</span>: <span style=color:#66d9ef>thrift.TTransport</span>;
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>new</span> (<span style=color:#a6e22e>trans</span>: <span style=color:#66d9ef>thrift.TTransport</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>TProtocol</span>;
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>tracer</span>:<span style=color:#66d9ef>opentelemetry.Tracer</span>;
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>serverSupportTracing</span>: <span style=color:#66d9ef>boolean</span>;

    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>output</span>: <span style=color:#66d9ef>thrift.TTransport</span>, <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>new</span> (<span style=color:#a6e22e>trans</span>: <span style=color:#66d9ef>thrift.TTransport</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>TProtocol</span>) {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_seqid</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_reqs</span> <span style=color:#f92672>=</span> {};
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>output</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>output</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>protocol</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>protocol</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tracer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>opentelemetry</span>.<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>getTracer</span>(<span style=color:#e6db74>&#39;SampleServiceClient&#39;</span>);
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverSupportTracing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
    }
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>incrementSeqId</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_seqid</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
    }
    
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>Int64</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>Int64</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt; {
        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>requestId</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>incrementSeqId</span>();
        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>span</span>:<span style=color:#66d9ef>opentelemetry.Span</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tracer</span>.<span style=color:#a6e22e>startSpan</span>(<span style=color:#e6db74>&#34;hello&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt;((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>=&gt;</span> {
            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_reqs</span>[<span style=color:#a6e22e>requestId</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>error</span>, <span style=color:#a6e22e>result</span>) <span style=color:#f92672>=&gt;</span> {
                <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_reqs</span>[<span style=color:#a6e22e>requestId</span>];
                
                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>error</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
                    <span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>error</span>);
                }
                <span style=color:#66d9ef>else</span> {
                    <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>result</span>);
                }
                <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>end</span>();
            };
            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>send_hello</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>requestId</span>);
        });
    }
}
</code></pre></div><p>這一段程式碼是截自 <a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>creditkarma/thrift-typescript</a> 從我的IDL產生的程式碼, 加上了tracer跟span, <code>startSpan</code>和<code>span.end</code>就插在hello裡面</p>
<p>這一段先用手工插入實驗後沒問題, 接下來我們就可以去改 <a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>creditkarma/thrift-typescript</a> 讓程式自動去產生</p>
<p>由於這邊牽涉多一點, 我就不一一解釋, 貼上我修改的<a href=https://github.com/julianshen/thrift-typescript/commit/5f2ebeb85f6e639be11d5184f5470ca8d4d466b9>commit</a>, 大家有興趣可以參考 : <a href=https://github.com/julianshen/thrift-typescript/commit/5f2ebeb85f6e639be11d5184f5470ca8d4d466b9>https://github.com/julianshen/thrift-typescript/commit/5f2ebeb85f6e639be11d5184f5470ca8d4d466b9</a></p>
<p>這樣一來, 產生我們要的client code就沒啥問題了</p>
<h2 id=傳遞追蹤資訊>傳遞追蹤資訊</h2>
<p>前面有提到<a href=https://twitter.github.io/finagle/>Finagle</a>有支援Zipkin Tracing, 只有client和server都是Finagle才可以在Thrift間傳遞追蹤資訊, 那實際上Finagle又是怎做的呢? 它的做法是在Thrift的通訊協定上做了一些小修改, 先來看看底下這三張圖</p>
<p><img src=/images/posts/twitterthrift.drawio.png alt="Twitter Thrift"></p>
<p>第一張是通常狀況, 在兩端都不支援傳遞追蹤資訊, 或是Client不支援, 就是走正常的路線, 第二三張則是在Client有支援(Finagle client), client會先送<code>__can__finagle__trace__v3__</code>這個呼叫確認server有支援, server如果有支援的話, 就會回傳正確的結果, 如果沒支援則會是 <code>UNKNOW_METHOD</code></p>
<p>Client在確認server有支援後, 後面的request就會先多帶一個header包含Tracing相關的資訊了</p>
<p>這部分, 我目前也只實做go版本的server, client版本尚未做, 這邊會需要做的部份包含:</p>
<ol>
<li>呼叫 <code>__can__finagle__trace__v3__</code> 確認是否支援tracing</li>
<li>將client端的tracing資訊帶入相關的header中</li>
</ol>
<p>如果client是用OpenTelemetry, 而server這邊是用Finagle加zipkin的話, 就得要注意Trace ID, Span ID的轉換, 這兩邊用的長度跟型別有點不太一樣, 轉換的範例如下:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UInt64ToTraceID</span>(<span style=color:#a6e22e>high</span>, <span style=color:#a6e22e>low</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#a6e22e>pdata</span>.<span style=color:#a6e22e>TraceID</span> {
	<span style=color:#a6e22e>traceID</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>16</span>]<span style=color:#66d9ef>byte</span>{}
	<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>PutUint64</span>(<span style=color:#a6e22e>traceID</span>[:<span style=color:#ae81ff>8</span>], <span style=color:#a6e22e>high</span>)
	<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>PutUint64</span>(<span style=color:#a6e22e>traceID</span>[<span style=color:#ae81ff>8</span>:], <span style=color:#a6e22e>low</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pdata</span>.<span style=color:#a6e22e>NewTraceID</span>(<span style=color:#a6e22e>traceID</span>)
}
</code></pre></div><p>(Source: <a href=https://github.com/open-telemetry/opentelemetry-collector/blob/6ae558c8757cad4ed29f7c9496b38827990f156f/internal/idutils/big_endian_converter.go#L24>https://github.com/open-telemetry/opentelemetry-collector/blob/6ae558c8757cad4ed29f7c9496b38827990f156f/internal/idutils/big_endian_converter.go#L24</a>)</p>
<p>只要在把這整段整合到code generator, 應該就可以大功告成了</p>
<p>雖然一開始覺得是個小題目, 沒想到居然讓我用這麼大篇幅介紹, 而且全部實做還沒完成, 看來是有點太過低估了</p>
<footer class=entry-meta>
<span class=entry-tags></span>
<div class=social-share>
<ul class="socialcount socialcount-small inline-list">
<li class=facebook><a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jln.co%2f%25E4%25BD%25BF%25E7%2594%25A8-OpenTelemetry-%25E8%25B7%25A8%25E4%25B8%258D%25E5%2590%258C%25E5%25B9%25B3%25E5%258F%25B0%25E8%25BF%25BD%25E8%25B9%25A4-Thrift-Rpc%2f" target=_blank title="Share on Facebook"><span class=count><i class="fa fa-facebook-square"></i> Like</span></a></li>
<li class=twitter><a href="https://twitter.com/intent/tweet?text=https%3a%2f%2fblog.jln.co%2f%25E4%25BD%25BF%25E7%2594%25A8-OpenTelemetry-%25E8%25B7%25A8%25E4%25B8%258D%25E5%2590%258C%25E5%25B9%25B3%25E5%258F%25B0%25E8%25BF%25BD%25E8%25B9%25A4-Thrift-Rpc%2f" target=_blank title="Share on Twitter"><span class=count><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
<li class=line><a href="https://social-plugins.line.me/lineit/share?url=https%3a%2f%2fblog.jln.co%2f%25E4%25BD%25BF%25E7%2594%25A8-OpenTelemetry-%25E8%25B7%25A8%25E4%25B8%258D%25E5%2590%258C%25E5%25B9%25B3%25E5%258F%25B0%25E8%25BF%25BD%25E8%25B9%25A4-Thrift-Rpc%2f" target=_blank title="Share on LINE"><span class=count><i class="fab fa-line"></i>LINE</span></a></li>
</ul>
</div>
</footer>
</div>
<section id=disqus_thread><div class=fb-comments data-href=https://blog.jln.co/%E4%BD%BF%E7%94%A8-OpenTelemetry-%E8%B7%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%BD%E8%B9%A4-Thrift-Rpc/ data-numposts=5 data-width></div></section>
</article>
</div>
<div class=footer-wrapper>
<footer role=contentinfo>
<span> Powered by <a href=https://gohugo.io/ rel=nofollow>Hugo</a> using the <a href=https://github.com/dldx/hpstr-hugo-theme rel=nofollow>HPSTR theme</a>.</span>
</footer>
</div>
<script src=//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js></script>
<script src=https://kit.fontawesome.com/872a53b461.js crossorigin=anonymous></script>
<script>window.jQuery||document.write('<script src="/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src=/js/scripts.min.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-79243751-1','auto'),ga('send','pageview'))</script>
<div id=fb-root></div>
<script async defer crossorigin=anonymous src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v7.0&appId=293999444006555&autoLogAppEvents=1" nonce=geZSUIUh></script>
</body>
</html>