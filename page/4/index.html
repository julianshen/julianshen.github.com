<!doctype html><!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=en><![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang=en><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang=en><![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en><!--<![endif]--><head><meta charset=utf-8><title>Le murmure de Julian</title><meta name=description content><meta property="og:title" content="Le murmure de Julian"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.jln.co/"><meta property="og:image" content="https://blog.jln.co/images/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.jln.co/images/avatar.png"><meta name=twitter:title content="Le murmure de Julian"><meta name=twitter:description content><link rel=canonical href=https://blog.jln.co/><link rel=alternate type=application/rss+xml href=https://blog.jln.co/feed.xml title="Le murmure de Julian"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/main.css><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel=stylesheet type=text/css><meta http-equiv=cleartype content="on"><meta name=generator content="Hugo 0.109.0"><script src=/js/vendor/modernizr-2.6.2.custom.min.js></script>
<script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script>
<link rel="shortcut icon" href=/favicon.png></head><body id=post-index class=feature><nav id=dl-menu class=dl-menuwrapper role=navigation style=display:inline-block><button class=dl-trigger>Open Menu</button><ul class=dl-menu><li><a href=/>Home</a></li><li><a href=#>About</a><ul class=dl-submenu><li><img src=/images/avatar.png alt="Julian Shen's photo" class=author-photo><h4>Julian Shen</h4><p>Softward developer</p></li><li><a href=mailto:julianshen22@gmail.com><i class="fa fa-fw fa-envelope"></i> Email</a></li><li><a href=https://linkedin.com/in/julianshen><i class="fa fa-fw fa-linkedin"></i> LinkedIn</a></li><li><a href=https://github.com/julianshen><i class="fa fa-fw fa-github"></i> GitHub</a></li><li><a href=https://instagram.com/julianshen><i class="fa fa-fw fa-instagram"></i> Instagram</a></li></ul></li><li><a href=#>Posts</a><ul class=dl-submenu><li><a href=/post/>All Posts</a></li><li><a href=/tags/>All Tags</a></li></ul></li><li><a href=/></a></li></ul></nav><div class=entry-header><div class=entry-image><img src=/images/bkg2.jpg alt="Le murmure de Julian"></div><div class=header-title><div class=header-title-wrap><h1><a href=/ title="Go to the homepage">Le murmure de Julian</a></h1><h2>朱隸安貓囈語錄</h2></div></div></div><div id=main role=main><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2021-08-22 12:42:50 +0800 +0800"><a href=/%E7%94%A8Kubernetes-ConfigMap%E5%AF%A6%E7%8F%BE%E9%85%8D%E7%BD%AE%E7%9A%84%E7%86%B1%E6%9B%B4%E6%96%B0/>Aug 22, 2021</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~7 minutes</span></div><h1 class=entry-title><a href=/%E7%94%A8Kubernetes-ConfigMap%E5%AF%A6%E7%8F%BE%E9%85%8D%E7%BD%AE%E7%9A%84%E7%86%B1%E6%9B%B4%E6%96%B0/ rel=bookmark title="用Kubernetes ConfigMap實現配置的熱更新" itemprop=url>用Kubernetes ConfigMap實現配置的熱更新</a></h1></header><div class=entry-content><p>程式配置(Configuration)的熱更新(hot reload)應該是建置服務會常碰到一個題目, 常會有狀況需要在不動用release去調整程式配置的狀況, 比較常見的做法應該是將這些配置集中管理, 因此就有相關的解決方案產生像是:</p><ul><li><a href=https://cloud.spring.io/spring-cloud-config/multi/multi__spring_cloud_config_server.html>Spring cloud config server</a></li><li><a href=https://github.com/Netflix/archaius>Netflix Archaius</a></li><li><a href=https://line.github.io/centraldogma/>LINE Central Dogma</a></li><li><a href=https://www.hashicorp.com/products/consul>HashiCorp Consul</a> (不過近來這個產品已經被延伸到Service Mash的領域去了)</li><li><a href=https://azure.microsoft.com/en-us/services/app-configuration/>Azure App configuration</a></li></ul><p>真要找, 應該還有, 這種中央管理的方式, 無非就是想要把分布在不同系統的所有的設定, 做一個集中管理, 隨時可以進行線上更新, 不過帶來的問題點就是除了要綁定選定系統用相關的API開發外, 這類的服務也是有可能是SPOF</p><p>在Kubernetes原生(Kubernetes Native)的角度來看這件事, Kubernetes就有內建ConfigMap, Secret, 是否還有必要導入這類的解決方案? 利用ConfigMap是否可以達成線上做熱更新的目的? 我的想法是, 如果用ConfigMap做到熱更新, 那麼搭配 GitOps 的流程, 這樣就可以做到簡單又兼顧集中管理的特性了(更新紀錄在git都可以查到, 另外可以用PR確保更改配置的安全性, 避免誤更, 在多叢集配置下也可以分享同一個git repository)</p><h2 id=使用configmap>使用ConfigMap</h2><p>這邊沒特別要說明怎麼去用ConfigMap, 那個 <a href=https://kubernetes.io/docs/concepts/configuration/configmap/>官方文件</a> 寫得很清楚, 先來看看ConfigMap在配合Pod/Deployment的兩個常見用法</p><p>先拿下面這範例來看:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>game-demo</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># property-like keys; each key maps to a simple value</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>player_initial_lives</span>: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ui_properties_file_name</span>: <span style=color:#e6db74>&#34;user-interface.properties&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># file-like keys</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>game.properties</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    player.maximum-lives=5    </span>    
</span></span><span style=display:flex><span>  <span style=color:#f92672>user-interface.properties</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    allow.textmode=true </span>    
</span></span></code></pre></div><p>上面這個ConfigMap我們可以在Pod這樣使用它:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>configmap-demo-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>demo</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>alpine</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;sleep&#34;</span>, <span style=color:#e6db74>&#34;3600&#34;</span>]
</span></span><span style=display:flex><span>      <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Define the environment variable</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>PLAYER_INITIAL_LIVES</span> <span style=color:#75715e># Notice that the case is different here</span>
</span></span><span style=display:flex><span>                                     <span style=color:#75715e># from the key name in the ConfigMap.</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>configMapKeyRef</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>name</span>: <span style=color:#ae81ff>game-demo          </span> <span style=color:#75715e># The ConfigMap this value comes from.</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>key</span>: <span style=color:#ae81ff>player_initial_lives</span> <span style=color:#75715e># The key to fetch.</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>UI_PROPERTIES_FILE_NAME</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>configMapKeyRef</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>name</span>: <span style=color:#ae81ff>game-demo</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>key</span>: <span style=color:#ae81ff>ui_properties_file_name</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>config</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>mountPath</span>: <span style=color:#e6db74>&#34;/config&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># You set volumes at the Pod level, then mount them into containers inside that Pod</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>config</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>configMap</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Provide the name of the ConfigMap you want to mount.</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>game-demo</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># An array of keys from the ConfigMap to create as files</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>items</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;game.properties&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#e6db74>&#34;game.properties&#34;</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;user-interface.properties&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#e6db74>&#34;user-interface.properties&#34;</span>
</span></span></code></pre></div><p>一個是用<code>valueFrom</code>把ConfigMap裡面的設定拿來放在環境變數使用(參考上面範例)</p><p>另一個則是透過 <code>volumes</code> 把設定內容掛載成檔案</p><p>為了達成熱更新, 我們會有興趣的是, 當我們ConfigMap更新時, 相對應的內容會不會改變, 答案是只有第二種掛載成檔案的, 會隨之更新, 而第一種, 當ConfigMap更新時, 相關的環境變數是不會跟著變的</p><p>至於掛載成檔案的, 當ConfigMap內容做過更動時, 相對應的檔案內容也會更新, 但&mldr;不是即時的, 根據文件</p><blockquote><p>The kubelet checks whether the mounted ConfigMap is fresh on every periodic sync. However, the kubelet uses its local cache for getting the current value of the ConfigMap. The type of the cache is configurable using the ConfigMapAndSecretChangeDetectionStrategy field in the KubeletConfiguration struct. A ConfigMap can be either propagated by watch (default), ttl-based, or by redirecting all requests directly to the API server. As a result, the total delay from the moment when the ConfigMap is updated to the moment when new keys are projected to the Pod can be as long as the kubelet sync period + cache propagation delay, where the cache propagation delay depends on the chosen cache type (it equals to watch propagation delay, ttl of cache, or zero correspondingly).</p></blockquote><p>也就是說預期會有根據你設定是用watch, ttl-based, 全透過API取得更新跟cache時間造成的時間差, 也就是雖然ConfigMap也是一種集中式管理(放在etcd), 但實際上還是會有數秒到數十秒的更新時間差(我實測最多碰到一分鐘後才更新)</p><p>因此如果需要做到配置的熱更新, 那我們可以選擇是第二種掛載成檔案的作法, 藉由監控檔案內容的改變, 再由程式去做熱更新</p><h2 id=觀測configmap的異動狀況>觀測ConfigMap的異動狀況</h2><p>既然是檔案, 那我們可不可以由Linux的inotify去監控檔案的異動狀況? inotify是Linux核心的一個系統呼叫, 現在主流伺服端的程式設計應該也比較少用C直接去呼叫這些System call了吧? 不過, 基本上還是可行的, 這邊有一篇"<a href=https://cloud.tencent.com/developer/article/1557278>用 Sidecar 应用 Configmap 更新</a>", 這邊就用 <code>inotifywait</code> 這個指令放在sidecar中去監控config檔案, 在有變動時, 發送訊號重啟主程序</p><p>這方法的優點是, 程式可以不用自行監控ConfigMap的變化, 缺點就是, 重啟這件事是不可控的, 當你的服務有多個實體(instance)時, 也有可能這些全部會在同一時間被重啟, 造成你的服務被下線</p><p>另外一個就是在程式內自行監控, 現在Kubernetes大行其道, 已然是顯學, 如果已經採用它來管理配置系統的話, 在設計上配合它來做, 也是無可厚非, Dev要能針對Ops來設計, 才能真的有DevOps, 更何況這部分只需要監控檔案, 並不需要綁死Kubernetes API</p><p>監控檔案異動的作法, 各語言有自己包裝, golang有<a href=https://fsnotify.org/>fsnotify</a>, Java則有nio裡的<a href=https://www.baeldung.com/java-nio2-watchservice>WatcherService</a></p><p>這邊先以Java Nio做一個簡單的測試(實際是以Kotlin實作):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>watchConfig</span>(configFileName: String) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> dir:Path = <span style=color:#a6e22e>Paths</span>.<span style=color:#66d9ef>get</span>(configFileName).parent
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> fileName = <span style=color:#a6e22e>Paths</span>.<span style=color:#66d9ef>get</span>(configFileName).fileName
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> watcher = <span style=color:#a6e22e>FileSystems</span>.getDefault().newWatchService()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	dir.register(watcher, <span style=color:#a6e22e>StandardWatchEventKinds</span>.ENTRY_CREATE, <span style=color:#a6e22e>StandardWatchEventKinds</span>.ENTRY_DELETE, <span style=color:#a6e22e>StandardWatchEventKinds</span>.ENTRY_MODIFY)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>val</span> key =watcher.take()
</span></span><span style=display:flex><span>		key.pollEvents().forEach { <span style=color:#66d9ef>it</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>it</span>.context() <span style=color:#f92672>==</span> fileName) {
</span></span><span style=display:flex><span>				reloadConfig()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(!key.reset()) {
</span></span><span style=display:flex><span>			key.cancel()
</span></span><span style=display:flex><span>			watcher.close()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以前面config map掛載的範例來看的話, 假設, 我們用 <code>watchConfig("/config/game.properties")</code> 來監控"/config/game.properties", 這邊的"/config/game.properties"是由ConfigMap裡的 <code>game.properties</code> 來的, 所以變更這邊的<code>game.properties</code>, &ldquo;/config/game.properties"也會跟著改變</p><p>但, 上面這段程式是"完全沒用的&rdquo;, 即使 <code>game.properties</code>和<code>/config/game.properties</code>內容都被改變了, 這邊的 <code>reloadConfig()</code> 也完全不會被觸發!!!! 如果使用golang的fsnotify, 也會是一樣的狀況</p><p>為什麼呢? 難道是這樣掛載的檔案有啥特異? 先來 <code>ls -l</code>看一下:</p><pre tabindex=0><code>ls -l /config/game.properties
lrwxrwxrwx 1 root root 24 Aug 21 16:55 /config/game.properties -&gt; ..data/game.properties
</code></pre><p>這邊可以發現<code>/config/game.properties</code>是一個Symbolic link連到<code>..data/game.properties</code>去, 這樣就導致我們監控不到它嗎? 其實還不只, 再來<code>ls -l ..data</code>看看</p><pre tabindex=0><code>ls -l ..data
lrwxrwxrwx 1 root root 31 Aug 21 16:58 ..data -&gt; ..2021_08_21_16_56_33.873456784
</code></pre><p>Ok, <code>..data</code>也是一個Symbolic link, 所以實際上ConfigMap被變更過後, 真正檔案變更大guy會是這樣的:</p><pre tabindex=0><code>CREATE ..2021_08_21_16_58_04.661956783
CREATE ..2021_08_21_16_58_04.661956783/game.properties
CREATE ..data_tmp (link to ..2021_08_21_16_58_04.661956783)
MOVE ..data_tmp ..data
DELETE ..2021_08_21_16_56_33.873456784
</code></pre><p>所以我們原本直覺應該會是認為它是會直接變更<code>/config/game.properties</code>內容, 但實際上<code>/config/game.properties</code>是一直沒被變動的, 它一直是一個連結到<code>/config/..data/game.properties</code>的Symbolic link, 所以觀測對象是不對的, 因此得這樣改:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>watchConfig</span>(configFileName: String) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> path:Path = <span style=color:#a6e22e>Paths</span>.<span style=color:#66d9ef>get</span>(configFileName)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> parent:Path = path.parent
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>Files</span>.isSymbolicLink(path)) {
</span></span><span style=display:flex><span>		path = <span style=color:#a6e22e>Files</span>.readSymbolicLink(path)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> realParent:String = path.parent.name
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> watcher = <span style=color:#a6e22e>FileSystems</span>.getDefault().newWatchService()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	parent.register(watcher, <span style=color:#a6e22e>StandardWatchEventKinds</span>.ENTRY_CREATE, <span style=color:#a6e22e>StandardWatchEventKinds</span>.ENTRY_DELETE, <span style=color:#a6e22e>StandardWatchEventKinds</span>.ENTRY_MODIFY)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>val</span> key =watcher.take()
</span></span><span style=display:flex><span>		key.pollEvents().forEach { <span style=color:#66d9ef>it</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>it</span>.context() <span style=color:#f92672>==</span> realParent) {
</span></span><span style=display:flex><span>				reloadConfig()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(!key.reset()) {
</span></span><span style=display:flex><span>			key.cancel()
</span></span><span style=display:flex><span>			watcher.close()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這邊的<code>realParent</code>其實就是<code>..data</code>, 有變動的會是它, 所以監控它就好了</p><h2 id=使用golang的spf13viper>使用golang的spf13/viper</h2><p>如果你是用golang並且是用sp13大神的<a href=https://github.com/spf13/viper>viper</a>, 來管理設定檔, 那你只需要透過<code>viper.WatchConfig()</code>來監控ConfigMap掛載下來的設定檔就好</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>viper</span>.<span style=color:#a6e22e>WatchConfig</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>viper</span>.<span style=color:#a6e22e>OnConfigChange</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>fsnotify</span>.<span style=color:#a6e22e>Event</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Config file changed:&#34;</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>這是因為<a href=https://github.com/spf13/viper>viper</a>有針對這一狀況修正過, 有興趣可以參考<a href=https://github.com/spf13/viper/commit/e0f7631cf3ac7e7530949c7e154855076b0a4c17>&ldquo;WatchConfig and Kubernetes (#284)&rdquo;</a>這段</p><h2 id=reloader>Reloader</h2><p>如果程式不想配合著改, 或大部分都是透過環境變數的方式來使用ConfigMap的話, 又怕使用前面inotify sidecar的作法會造成問題, 希望有更好的方式去RollOut, 那可以參考一下<a href=https://github.com/stakater/Reloader>Reloader</a></p><p><a href=https://github.com/stakater/Reloader>Reloader</a>會去監控ConfigMap跟Secret的變動, 來重啟跟他們有相關的DeploymentConfigs, Deployments, Daemonsets Statefulsets 和 Rollouts, 由於它是以Kubernetes conrtroller的形式存在, 並且採用Kubernetes API去監控資源: <a href=https://github.com/stakater/Reloader/blob/99a38bff8ea1346191b6a96583d3fbad72573ea5/internal/pkg/controller/controller.go#L47>https://github.com/stakater/Reloader/blob/99a38bff8ea1346191b6a96583d3fbad72573ea5/internal/pkg/controller/controller.go#L47</a></p><p>安裝方法很簡單, 只需要用:</p><pre tabindex=0><code>kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml
</code></pre><p>裝到你所需要的namespace即可, 然後在你的Deployment設定上加上一個annotation <code>reloader.stakater.com/auto: "true"</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>reloader.stakater.com/auto</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span></code></pre></div><p>這樣reloader就會幫你監控這個Deployment用到相關的ConfigMap跟Secret, 不管是用環境變數的方式, 還是掛載檔案的方式, 都適用, 並且由於它是直接透過Kubernetes API, 因此ConfigMap或是Secret有變化都是即時會監測到, 然後它就會用rolling update的方式去重啟相關的instances, 相較之下會比用sidecar的方式保險</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2021-08-20 19:11:48 +0800 +0800"><a href=/%E7%94%A8gradlesbt%E7%9B%B4%E6%8E%A5%E5%BB%BA%E7%BD%AEDocker-Image/>Aug 20, 2021</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~2 minutes</span></div><h1 class=entry-title><a href=/%E7%94%A8gradlesbt%E7%9B%B4%E6%8E%A5%E5%BB%BA%E7%BD%AEDocker-Image/ rel=bookmark title="用gradle／sbt直接建置Docker Image" itemprop=url>用gradle／sbt直接建置Docker Image</a></h1></header><div class=entry-content><p>現在流行甚麼東西都要包成Docker image來部署, 每一個都要寫一個Dockerfile, 每個又很類似, 建置完程式碼又得立刻跑Docker來建置Docker image, 如果有更簡單的方法可以一次做完, 應該會省事很多</p><p>以下提到的這些方法可以一行Dockerfile都不用寫</p><h2 id=使用gradle把java-application建置並包裝成docker-image>使用gradle把Java application建置並包裝成Docker image</h2><p>要達到這個目的, 可以使用 <code>com.bmuschko.docker-java-application</code> - <a href=https://bmuschko.github.io/gradle-docker-plugin/#java-application-plugin>https://bmuschko.github.io/gradle-docker-plugin/#java-application-plugin</a> 這個Gradle plugin, 這個plugin會去呼叫Docker client API, 所以使用前確定你有啟動dockerd</p><p>先來看一下底下這範例, 這是一個用<a href=https://ktor.io/>Ktor</a>寫的server application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> ktor_version: String <span style=color:#66d9ef>by</span> project
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> kotlin_version: String <span style=color:#66d9ef>by</span> project
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> logback_version: String <span style=color:#66d9ef>by</span> project
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plugins {
</span></span><span style=display:flex><span>    application
</span></span><span style=display:flex><span>    kotlin(<span style=color:#e6db74>&#34;jvm&#34;</span>) version <span style=color:#e6db74>&#34;1.5.21&#34;</span>
</span></span><span style=display:flex><span>    id(<span style=color:#e6db74>&#34;com.bmuschko.docker-java-application&#34;</span>) version <span style=color:#e6db74>&#34;6.7.0&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>group = <span style=color:#e6db74>&#34;co.jln&#34;</span>
</span></span><span style=display:flex><span>version = <span style=color:#e6db74>&#34;0.0.1&#34;</span>
</span></span><span style=display:flex><span>application {
</span></span><span style=display:flex><span>    mainClass.<span style=color:#66d9ef>set</span>(<span style=color:#e6db74>&#34;co.jln.ApplicationKt&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker {
</span></span><span style=display:flex><span>    javaApplication {
</span></span><span style=display:flex><span>        baseImage.<span style=color:#66d9ef>set</span>(<span style=color:#e6db74>&#34;openjdk:11-jre&#34;</span>)
</span></span><span style=display:flex><span>        ports.<span style=color:#66d9ef>set</span>(listOf(<span style=color:#ae81ff>8080</span>))
</span></span><span style=display:flex><span>        images.<span style=color:#66d9ef>set</span>(setOf(<span style=color:#e6db74>&#34;julianshen/myexamplekt:&#34;</span> + version, <span style=color:#e6db74>&#34;julianshen/myexamplekt:latest&#34;</span>))
</span></span><span style=display:flex><span>        jvmArgs.<span style=color:#66d9ef>set</span>(listOf(<span style=color:#e6db74>&#34;-Xms256m&#34;</span>, <span style=color:#e6db74>&#34;-Xmx2048m&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>repositories {
</span></span><span style=display:flex><span>    mavenCentral()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dependencies {
</span></span><span style=display:flex><span>    implementation(<span style=color:#e6db74>&#34;io.ktor:ktor-server-core:</span><span style=color:#e6db74>$ktor</span><span style=color:#e6db74>_version&#34;</span>)
</span></span><span style=display:flex><span>    implementation(<span style=color:#e6db74>&#34;io.ktor:ktor-server-netty:</span><span style=color:#e6db74>$ktor</span><span style=color:#e6db74>_version&#34;</span>)
</span></span><span style=display:flex><span>    implementation(<span style=color:#e6db74>&#34;ch.qos.logback:logback-classic:</span><span style=color:#e6db74>$logback</span><span style=color:#e6db74>_version&#34;</span>)
</span></span><span style=display:flex><span>    testImplementation(<span style=color:#e6db74>&#34;io.ktor:ktor-server-tests:</span><span style=color:#e6db74>$ktor</span><span style=color:#e6db74>_version&#34;</span>)
</span></span><span style=display:flex><span>    testImplementation(<span style=color:#e6db74>&#34;org.jetbrains.kotlin:kotlin-test:</span><span style=color:#e6db74>$kotlin</span><span style=color:#e6db74>_version&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>雖然是kotlin寫的, 不過這是一個標準的Java Application, 有它的main class, 我們要加上的只有 <code>id("com.bmuschko.docker-java-application") version "6.7.0"</code> 和 <code>docker {}</code> 內的內容而已, 基本主要就是baseImage跟image的名字就好了</p><p>執行 <code>gradle dockerBuildImage</code> 就可以直接幫你把程式建置好並包裝成docker image了</p><p>如果是要把image給push到repository上的話, 執行 <code>gradle dockerPushImage</code></p><p>如果你的不是一般的Java application 而是Spring boot application的話, 則是可以用 <code>com.bmuschko.docker-spring-boot-application</code> 這個plugin而不是上面那個, 不過如果是Spring boot 2.3之後, 還有另一個方法</p><h2 id=直接把spring-boot應用程式建置成docker-image>直接把Spring Boot應用程式建置成Docker image</h2><p>如果是Spring Boot 2.3之後, 因為內建就有支援 <a href=https://buildpacks.io/>Cloud Native Buildpacks</a> , 所以直接就可以建置成docker image , 蠻簡單的, 只要執行</p><pre tabindex=0><code>gradle bootBuildImage
</code></pre><p>不過, 它image的名字會是 <code>library/project_name</code> , 所以如果你需要用其他的名字取代的話, 有兩種方法, 一種是加上 <code>--imageName</code> 給定名字, 像是:</p><pre tabindex=0><code>gradle bootBuildImage --imageName=julianshen/springsample
</code></pre><p>另一種是把這段加到 <code>build.gradle.kts</code> 去(這邊以kotlin當範例):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>tasks.getByName&lt;org.springframework.boot.gradle.tasks.bundling.BootBuildImage&gt;(<span style=color:#e6db74>&#34;bootBuildImage&#34;</span>) {
</span></span><span style=display:flex><span>	docker {
</span></span><span style=display:flex><span>		imageName = <span style=color:#e6db74>&#34;julianshen/sprintsmaple&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這個的缺點是, 不像前面提到的plugin有支援push, 如果你需要把建置好的結果放到repository上的話, 就得自己執行 <code>docker push</code></p><h2 id=把scala-application包裝成docker-image>把Scala application包裝成Docker image</h2><p>如果是Scala就需要用到 <a href=https://www.scala-sbt.org/sbt-native-packager/index.html>SBT Native Packager</a></p><p>用法也不難, 首先先把下面這段加到 <code>plugins.sbt</code> 去:</p><pre tabindex=0><code>addSbtPlugin(&#34;com.typesafe.sbt&#34; % &#34;sbt-native-packager&#34; % &#34;1.7.6&#34;)
</code></pre><p>在 <code>build.sbt</code> 內加入:</p><pre tabindex=0><code>enablePlugins(DockerPlugin)
</code></pre><p>然後執行 <code>sbt docker:publishLocal</code>即可, 相關設定可以參考 <a href=https://www.scala-sbt.org/sbt-native-packager/formats/docker.html>Docker plugin的文件</a></p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2021-08-15 15:29:09 +0800 +0800"><a href=/%E7%AD%86%E8%A8%98-%E4%BD%BF%E7%94%A8Lens-%E7%AE%A1%E7%90%86%E5%8F%8A%E7%9B%A3%E6%8E%A7MicroK8s/>Aug 15, 2021</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~3 minutes</span></div><h1 class=entry-title><a href=/%E7%AD%86%E8%A8%98-%E4%BD%BF%E7%94%A8Lens-%E7%AE%A1%E7%90%86%E5%8F%8A%E7%9B%A3%E6%8E%A7MicroK8s/ rel=bookmark title="[筆記] 使用Lens 管理及監控MicroK8s" itemprop=url>[筆記] 使用Lens 管理及監控MicroK8s</a></h1></header><div class=entry-content><p>自從離職後, 就沒一個方便的環境可以來做實驗, 家裡的desktop要裝k8s雖然是夠, 但出門的話, 我只有一台六七年的notebook改了SSD裝了Linux, 還是想在這台NB裝K8S拿來玩一些東西</p><h2 id=microk8s>MicroK8s</h2><p><a href=https://microk8s.io/>MicroK8s</a> 算是一個不錯的選擇, 輕量化, 單機可以跑, 重要的是, 可以隨時開關, 對於我這台老電腦來說, 需要的時候再開就好</p><p>安裝方式很簡單(Linux下需要先有<a href=https://snapcraft.io/docs/installing-snapd>snap</a>):</p><pre tabindex=0><code>sudo snap install microk8s --classic
</code></pre><p>使用 <code>microk8s status</code> 可以看目前狀態, <code>microk8s start</code>可以開始執行, <code>microk8s stop</code>即可停止</p><pre tabindex=0><code># microk8s status
microk8s is not running, try microk8s start
# microk8s start
[sudo] password for julianshen:            
Started.
# microk8s status
microk8s is running
high-availability: no
  datastore master nodes: 127.0.0.1:19001
  datastore standby nodes: none
addons:
  enabled:
    cilium               # SDN, fast with full network policy
    dashboard            # The Kubernetes dashboard
    dns                  # CoreDNS
    ha-cluster           # Configure high availability on the current node
    helm                 # Helm 2 - the package manager for Kubernetes
    helm3                # Helm 3 - Kubernetes package manager
    ingress              # Ingress controller for external access
    metrics-server       # K8s Metrics Server for API access to service metrics
    prometheus           # Prometheus operator for monitoring and logging
    registry             # Private image registry exposed on localhost:32000
    storage              # Storage class; allocates storage from host directory
  disabled:
    ambassador           # Ambassador API Gateway and Ingress
    fluentd              # Elasticsearch-Fluentd-Kibana logging and monitoring
    gpu                  # Automatic enablement of Nvidia CUDA
    host-access          # Allow Pods connecting to Host services smoothly
    istio                # Core Istio service mesh services
    jaeger               # Kubernetes Jaeger operator with its simple config
    keda                 # Kubernetes-based Event Driven Autoscaling
    knative              # The Knative framework on Kubernetes.
    kubeflow             # Kubeflow for easy ML deployments
    linkerd              # Linkerd is a service mesh for Kubernetes and other frameworks
    metallb              # Loadbalancer for your Kubernetes cluster
    multus               # Multus CNI enables attaching multiple network interfaces to pods
    openebs              # OpenEBS is the open-source storage solution for Kubernetes
    openfaas             # openfaas serverless framework
    portainer            # Portainer UI for your Kubernetes cluster
    rbac                 # Role-Based Access Control for authorisation
    traefik              # traefik Ingress controller for external access
</code></pre><p>如果是正在執行的狀態下, <code>microk8s status</code> 可以看到有哪些可用的addon, 如果要啟動其中一個addon(例如trafik), 也只要執行 <code>microk8s enable traefik</code>, 非常簡單</p><p>最基本來說, 你可以使用 <code>microk8s kubectl</code> 來執行相關的 <code>kubectl</code>指令, 如果要方便的GUI界面來管理的話, 也可以透過啟動dashboard:</p><pre tabindex=0><code># microk8s enable dashboard
Enabling Kubernetes Dashboard
Addon metrics-server is already enabled.
Applying manifest
serviceaccount/kubernetes-dashboard created
service/kubernetes-dashboard created
secret/kubernetes-dashboard-certs created
secret/kubernetes-dashboard-csrf created
secret/kubernetes-dashboard-key-holder created
configmap/kubernetes-dashboard-settings created
role.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created
rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
deployment.apps/kubernetes-dashboard created
service/dashboard-metrics-scraper created
deployment.apps/dashboard-metrics-scraper created

If RBAC is not enabled access the dashboard using the default token retrieved with:

token=$(microk8s kubectl -n kube-system get secret | grep default-token | cut -d &#34; &#34; -f1)
microk8s kubectl -n kube-system describe secret $token

In an RBAC enabled setup (microk8s enable RBAC) you need to create a user with restricted
permissions as shown in:
https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md

# microk8s dashboard-proxy 
Checking if Dashboard is running.
Dashboard will be available at https://127.0.0.1:10443
Use the following token to login:
[TOKEN]
</code></pre><p>不過, 我個人是比較偏好用<a href=https://k8slens.dev/>Lens</a></p><h2 id=lens>Lens</h2><p><img src=/images/posts/lens_startup.png alt></p><p>Lens的界面蠻簡單直覺的, 功能也蠻強大的, 除了管理你的cluster外, 也可以作到簡單的監控, 同時也可以管理多個cluster, 在啟動Lens後, 到"Clusters Catalog", 會發現沒有任何的一個cluster, 也沒有剛剛啟動的MicroK8S cluster</p><p><img src=/images/posts/lens_cluster_no.png alt></p><p>有兩個方法可以加入剛剛創建的MicroK8s cluster, 第一個是按下那個"+&ldquo;按鈕:</p><p><img src=/images/posts/lens_add.png alt></p><p>這時候把k8s config貼進去就好, 這邊要注意的一點是, 本來獲取k8s config可以用 <code>kubectl config view</code> , 在MicroK8s下, 如果沒特別設定, 都是用 <code>microk8s kubectl</code> 取代 <code>kubectl</code>, 但這邊, 如果你用 <code>microk8s kubectl config view</code> 去取得k8s config的話, 貼上去, Lens是會連不上你的cluster的</p><p>這邊應該用 <code>microk8s config</code>才對, 這個才能讓你的Lens正確連上</p><p>另一個方式是執行 <code>microk8s config > ~/.kube/config</code> , 這樣Lens就會自動抓到了, 這兩種的優缺點是, 直接在Lens設定k8s config的話, 管理多個clusters時, 可以不用一直切換context, 如果直接使用 &ldquo;.kube/config&rdquo; 的話, 則是, 你也可以直接使用 <code>kubectl</code>來操作你的cluster(就不需要用<code>microk8s kubectl</code>)</p><p><img src=/images/posts/lens_connect.png alt></p><p>最後要做的步驟就是連接了, 按下"Connect"即可</p><p>在MicroK8s這邊, 要記得enable prometheus , Lens會去偵測Prometheus operator並抓取相關的metric資訊顯示在界面上</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2021-08-12 15:54:06 +0800 +0800"><a href=/%E6%B5%81%E7%A8%8B%E5%9C%96%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B-vscode-%E6%95%B4%E5%90%88-Drawio/>Aug 12, 2021</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~1 minute</span></div><h1 class=entry-title><a href=/%E6%B5%81%E7%A8%8B%E5%9C%96%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B-vscode-%E6%95%B4%E5%90%88-Drawio/ rel=bookmark title="流程圖的好幫手: vscode 整合 Drawio" itemprop=url>流程圖的好幫手: vscode 整合 Drawio</a></h1></header><div class=entry-content><p>本來我寫blog畫流程圖都用<a href=https://github.com/mermaid-js/mermaid>Mermaid</a>, 不過由於不好預覽, 要畫比較複雜的圖也有點麻煩</p><p><a href=https://app.diagrams.net/>Draw.io</a>是一個不錯的免費工具, 蠻便利好用的, 但缺點就是是網頁版的, 要跟平常寫文章的流程整合比較不方便, 由於我是在vscode上寫文章的, 所以發現了 <a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio">Draw.io Integration</a> 這個vscode的extension, 蠻方便的</p><p><img src=https://raw.githubusercontent.com/hediet/vscode-drawio/2387501b949e43692efa027eb82255f3d060d8c3/docs/drawio-png.gif alt></p><p>除了可以直接在vscode上編輯流程圖外, 如果你的檔名是"XXXX.drawio.png", 或是 &ldquo;XXXX.drawio.svg&rdquo; 畫完後就直接輸出成png/svg, 就可以直接拿來用了, 有問題也可以直接改, 不用轉檔轉來轉去的</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2021-08-12 00:35:55 +0800 +0800"><a href=/%E4%BD%BF%E7%94%A8-OpenTelemetry-%E8%B7%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%BD%E8%B9%A4-Thrift-Rpc/>Aug 12, 2021</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>
Reading time ~12 minutes</span></div><h1 class=entry-title><a href=/%E4%BD%BF%E7%94%A8-OpenTelemetry-%E8%B7%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%BD%E8%B9%A4-Thrift-Rpc/ rel=bookmark title="使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc" itemprop=url>使用 OpenTelemetry 跨不同平台追蹤 Thrift Rpc</a></h1></header><div class=entry-content><p>在離職前一周研究的一個小題目, 說小其實也蠻難搞的, 搞到這兩天重新看, 才釐清完整做法</p><p>難搞的原因有幾個, 雖然<a href=https://opentelemetry.io/>OpenTelemetry</a>有支援<a href=https://grpc.io/>gRPC</a>, 但對於 <a href=http://thrift.apache.org/>Thrift</a> 就沒人做相關的支援了, 再來就是系統環境跨了nodejs和<a href=https://twitter.github.io/finagle/>Finagle</a>/Scala兩種平台, Thrift 是用在這兩者之間的溝通, Finagle雖是有支援<a href=https://zipkin.io/>ZipKin</a><a href=https://twitter.github.io/finagle/guide/Tracing.html>做分散式追蹤</a>, 但那僅限於Finagle client呼叫Finagle server的部分才有支援在這之間傳遞追蹤資訊, 跨nodejs (client) 到 Finagle (server), 這邊也一樣找不到啥資訊</p><p>所以這邊主要會想做到的:</p><ol><li>自動插入追蹤的程式碼</li><li>在 Thrift client/server 間傳遞追蹤資訊 (client/server不同平台)</li></ol><p>大致上的原理有做過些小實驗, 確定應該可行, 只是懶得把整套完整做好就是了</p><h2 id=分散式追蹤-distributed-tracinghttpslightstepcomdistributed-tracing><a href=https://lightstep.com/distributed-tracing/>分散式追蹤 Distributed Tracing</a></h2><p>在大型的分散式系統, 一個從使用者端來的request通常都會被分發到不同的系統去做處理, 尤其現在大多流行微服務(Micro services)架構, 這種狀況相當的常見, 當問題發生的時候, 到底甚麼時間點在哪個系統, 碰到甚麼事, 要追查原因便得從這麼多系統分散且看不出關聯性的log去想辦法分析出來, 因此導入分散式追蹤, 就是為了解決這問題</p><p>最早出現應該是Google內部使用的Dapper, 也有發表相關的<a href=https://static.googleusercontent.com/media/research.google.com/en//archive/papers/dapper-2010-1.pdf>論文</a>, 開源的部分, 早期又有Twitter的<a href=https://zipkin.io/>ZipKin</a>和Uber的<a href=https://www.jaegertracing.io/>Jaeger</a>, 前面有提到的<a href=https://twitter.github.io/finagle/>Finagle</a>, 由於也是Twitter開源出來的應用程式框架, 所以<a href=https://twitter.github.io/finagle/>Finagle</a>出廠就支援<a href=https://zipkin.io/>ZipKin</a>也是理所當然的</p><p>後來又出現想要大一統的<a href=https://opentracing.io/>OpenTracing</a>和<a href=https://opencensus.io/>OpenCensus</a>, 這兩個後來又被大一統到這邊所要提到的<a href=https://opentelemetry.io/>OpenTelemetry</a></p><p>做Distributed Tracing雖然對追問題會有幫助, 但要導入並不見的容易, 先是要在所有要追蹤的插入追蹤程式碼, 對於既有系統的改動幅度自是不小, 此外, 早期, 不管是<a href=https://zipkin.io/>ZipKin</a>和Uber的<a href=https://www.jaegertracing.io/>Jaeger</a>還是<a href=https://www.jaegertracing.io/>Jaeger</a>考量的主要還是REST API的架構, REST是透過HTTP傳輸的, 因此在設計上, 就可以透過HTTP header帶追蹤相關資訊, 但在一個複雜的分散式系統, 可能包含不同的通訊協定, 像是REST, GraphQL, gRPC, Thrift, 或是呼叫資料庫之類的, 不見得都是透過HTTP, 那怎麼傳遞追蹤資訊就是個問題, 跨系統間如果無法分享追蹤資訊, 那也是白搭</p><h2 id=opentelemetryhttpsopentelemetryio><a href=https://opentelemetry.io/>OpenTelemetry</a></h2><p><a href=https://opentelemetry.io/>OpenTelemetry</a>其實也不是只有支援Distributed Tracing, 它能處理的資料型態, 主要就有下面這幾種:</p><ol><li>Traces</li><li>Metrics</li><li>Logs</li></ol><p>也就是說除了追蹤資訊, 它也囊括了系統狀態跟Logs, 另外也支援很多不同語言, 算是野心蠻大的, 這邊來看一下它的架構:</p><p><img src=https://raw.github.com/open-telemetry/opentelemetry.io/main/iconography/Reference_Architecture.svg alt></p><p>主要它包含了兩部分, 一個是各程式語言使用的程式庫 - OT Library, 另一個是蒐集資訊的Collector, 而Collector是這樣的:</p><p><img src=https://raw.github.com/open-telemetry/opentelemetry.io/main/iconography/Otel_Collector.svg alt></p><p>Collector包含了Receiver, Processor, Exporter, 這架構讓它有能力相容/支援不同的系統, 所以像是Finagle這種本來就有支援ZipKin的, 其實只要把原本倒到ZipKin的資料轉倒到OpenTelemetry的Collector就好, 這邊算是好解決, 如果系統是跑在K8S這類的環境上的話, 也可以考慮把Collector
當成sidecar來佈署</p><p>而各程式語言的程式庫的部分, 方便的是在某些程式語言有支援所謂的auto instrumentation, 針對有支援的程式庫或是框架, 可以在不寫任何程式碼或是寫少少的程式碼, 就可以達到分散式追蹤的目的(聽來有點玄), 像是Java就<a href=https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks>支援了這些</a>(請參考連結), 而<a href=https://github.com/open-telemetry/opentelemetry-js-contrib>Javascript有這些</a>(請參考連結)</p><p>但畢竟沒有甚麼是萬能的, 沒支援的還是得靠自己手動插追蹤的程式碼, 或是想辦法支援, 像是這篇正題的部分, 這邊想要追蹤從nodejs呼叫Finagle的部分, 就沒辦法使用現成的 (實際狀況更複雜, nodejs本身是graphql server, Finagle server又可能呼叫ElasticSearch或Kafka, 如果想全部串起來, 不算小, 這邊主要針對 nodejs &lt;-> Finagle部分)</p><h2 id=在nodejs下用opentelemetry做tracing>在Node.JS下用OpenTelemetry做Tracing</h2><p>基本使用上其實相當簡單, 可以參考這個<a href=https://opentelemetry.io/docs/js/getting_started/nodejs/>連結</a>, 先用一個小範例來解釋:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>HttpInstrumentation</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation-http&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>GrpcInstrumentation</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation-grpc&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>ExpressInstrumentation</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation-express&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>ConsoleSpanExporter</span>, <span style=color:#a6e22e>SimpleSpanProcessor</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/tracing&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>NodeTracerProvider</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/node&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>registerInstrumentations</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/instrumentation&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>provider</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NodeTracerProvider</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>addSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SimpleSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ConsoleSpanExporter</span>()));
</span></span><span style=display:flex><span><span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>register</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>registerInstrumentations</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>instrumentations</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HttpInstrumentation</span>(), 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>GrpcInstrumentation</span>(),
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ExpressInstrumentation</span>()
</span></span><span style=display:flex><span>      ],
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>以這範例來說, 它打開了支援http, grpc, express等程式庫的auto instrumentation, 亦即在你的程式中如果有用到這幾個程式庫, 它會自動加上對應的追蹤程式碼, 你不用額外做任何事, 從client到server都處理好, 或是你也可以像文件中用:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// This will automatically enable all instrumentations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>registerInstrumentations</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>instrumentations</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>getNodeAutoInstrumentations</span>()],
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><code>getNodeAutoInstrumentations()</code>包含了底下這幾種的資源:</p><ul><li><code>@opentelemetry/instrumentation-dns': DnsInstrumentation</code></li><li><code>@opentelemetry/instrumentation-express': ExpressInstrumentation</code></li><li><code>@opentelemetry/instrumentation-graphql': GraphQLInstrumentation</code></li><li><code>@opentelemetry/instrumentation-grpc': GrpcInstrumentation</code></li><li><code>@opentelemetry/instrumentation-http': HttpInstrumentation</code></li><li><code>@opentelemetry/instrumentation-ioredis': IORedisInstrumentation</code></li><li><code>@opentelemetry/instrumentation-koa': KoaInstrumentation</code></li><li><code>@opentelemetry/instrumentation-mongodb': MongoDBInstrumentation</code></li><li><code>@opentelemetry/instrumentation-mysql': MySQLInstrumentation</code></li><li><code>@opentelemetry/instrumentation-pg': PgInstrumentation</code></li><li><code>@opentelemetry/instrumentation-redis': RedisInstrumentation</code></li></ul><p>建議如果沒要追蹤這麼多東西的話, 還是一個個加就好, 畢竟資訊多雜訊也多</p><p>在這邊:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>provider</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NodeTracerProvider</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>provider</span>.<span style=color:#a6e22e>addSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>SimpleSpanProcessor</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ConsoleSpanExporter</span>()));
</span></span></code></pre></div><p>這兩行是建立Trace Provider, 告訴它要用哪個Processor或哪個Exporter去處理追蹤資訊, 這跟前面提到的Collector的架構上大致類似, 這邊用的是Consle exporter,也就是追蹤資訊會被直接印在螢幕上, 如果想輸出到ZipKin或是Jaeger就用相對應的Exporter就可以了, 或者也可以用OTLP的Exporter直接輸出到OpenTelemetry的collector</p><p>但這是在有支援的狀況下, 如果沒有呢? 就得手動去插了, 看一下下面這範例:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>opentelemetry</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@opentelemetry/api&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tracer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>opentelemetry</span>.<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>getTracer</span>(<span style=color:#e6db74>&#39;example-basic-tracer-node&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create a span. A span must be closed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>span</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tracer</span>.<span style=color:#a6e22e>startSpan</span>(<span style=color:#e6db74>&#39;main&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>doWork</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// Be sure to end the span.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>end</span>();
</span></span></code></pre></div><p>這是簡單追蹤一個程序的方法, 在這範例是<code>doWork()</code>, 這邊就可以追蹤從<code>startSpan</code>到<code>end</code>之間的耗費的時間了, 針對沒有支援auto instrumentation, 或是你想額外在你程式內追蹤些別的, 那就得用這種方式在需要追蹤的地方加入這些</p><p>很不幸的, 目前不管哪個語言, Java, Javascript, 都沒支援Thrift相關的, 所以如果要追蹤 Thrift, 可能就得是這樣, 除了可能需要改不少地方外, 插入這些code其實也不太好看啦 :p</p><h2 id=追蹤-thrift-rpc>追蹤 Thrift RPC</h2><p>Thrift算是一個有點歷史的RPC框架(framework)了, 雖然應該還有不少大公司像是Twitter, Facebook, LINE, LinkedIn還有在使用, 不過現在大家大部分應該是比較常用比較潮的gRPC, 比較少用Thrift了, 所以在OpenTelemetry這種新東西找不到支援應該也情有可原</p><p>為了比較好確認解決這問題的概念是怎樣, 這邊先把問題/架構先簡化如下:</p><ol><li>Thrift client: 跑在nodejs下, 以typescript開發</li><li>Thrift server: 跑在Twitter Finagle框架, 以scala開發 (事實上, 我也有實做一個go版本的server, 不過先不在這討論)</li></ol><p>所以這邊會需要知道的是:</p><ol><li>client呼叫每個Thrift call需要的時間</li><li>在server上每個call又對應哪些呼叫或花費</li></ol><p>用以下ZipKin這張圖來當範例, 就可以這樣一層層追蹤下去</p><p><img src=/images/posts/2021-08-12-11-43-50.png alt=ZipKin></p><p>Client部分雖然可以使用手工插入tracing相關的程式碼, 但當然還是做成自動的最好, 而且client必須要可以把相關的trace ID, span ID給傳遞到server, 要不然線索就會斷掉了</p><p>為了達到這目標, 首先我們先來看一下Thrift從Client到Server經過哪些地方:</p><p><img src=/images/posts/thrift.drawio.png alt=Thrift></p><p>從這圖看來, 可能可以插入追蹤碼的點可以是產生出來的Client code或是TProtocol的位置(為何?後面再提)</p><p>在前面我也寫了一篇"<a href=https://blog.jln.co/%E5%9C%A8nodejs%E4%BD%BF%E7%94%A8typescript%E5%91%BC%E5%8F%ABthrift-client/>在nodejs使用typescript呼叫thrift client</a>&ldquo;裡面有提到利用<code>thrift -r --gen js:ts smaple.thrift</code>來產生nodejs用的client code</p><p>以下面這個Thrift IDL來當範例:</p><pre tabindex=0><code>namespace java sample.thrift
#@namespace scala sample.thrift
namespace go rpc

service SampleService {
    string hello(1: i64 a, 2: i64 b)
    void hello2()
}
</code></pre><p>用<code>thrift -r --gen js:ts sample.thrift</code>就可以產生四個檔案, 分別是:</p><ol><li>sample_types.js</li><li>sample_types.d.ts</li><li>SampleService.js SampleService的定義</li><li>SampleService.d.ts SampleService的javascript實作(Client + Processor)</li></ol><p>再仔細去看SampleService.js, 以hello這個method為例, 你會發現在 <code>SampleServiceClient</code> 裡關於hello的部分有三部分:</p><ol><li><code>hello(a, b, callback)</code> 實際給程式呼叫的介面, 這邊回傳是個Promise</li><li><code>send_hello(a, b)</code> 會由hello去呼叫, 實際上負責傳遞呼叫的相關資訊</li><li><code>recv_hello(input,mtype,rseqid)</code> 當send_hello送出呼叫資訊到server後, Connection會等到Server回應後, 會呼叫 recv_functionname, 去處理回傳回來的資訊</li></ol><p>另外在 <code>send_hello</code> 的一開始會去呼叫 <code>output.writeMessageBegin('hello', Thrift.MessageType.CALL, this.seqid());</code> , 這邊的output是TProtocol, 在呼叫 <code>recv_hello</code> 之前則是會呼叫 <code>input.readMessageBegin()</code> 這邊也可以得到呼叫的method的資訊</p><p>由上面的線索看來, 可以插入追蹤程式碼可能的幾個點:</p><ol><li><code>hello(a, b, callback)</code> 的一開始到Promise結束</li><li><code>send_hello(a, b)</code>到<code>recv_hello(input,mtype,rseqid)</code>的結束</li><li><code>writeMessageBegin</code> 到 <code>readMessageBegin</code></li></ol><p>這邊問題在於 <code>hello</code>, <code>send_hello</code>, <code>recv_hello</code>都是由<code>thrift</code>這個指令產出的, 而<code>writeMessageBegin</code>, <code>readMessageBegin</code>則是在thrift的程式庫內</p><p>我們要怎樣在裡面插入追蹤的程式碼?或是有沒辦法做到auto instrumentation那樣?</p><h2 id=javascript-auto-instrumentation-in-opentelemetry>Javascript auto instrumentation in OpenTelemetry</h2><p>OpenTelemetry其實是有開放介面給大家去開發相關的auto instrumentation, 不過這一塊實在看得有點頭痛, 沒文件, 又不好懂, 我最後沒採用這方法實作, 但因為在這邊花了不少時間, 還是簡單的介紹一下</p><p>前面有提到的有許多auto instrumentation的實作, 都是被放到 <a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>opentelemetry-js-contrib/plugins/node</a>, 也就是說你可以用一樣的方法做出自己的auto instrumentation</p><p>其架構的原始碼可以參考<a href=https://github.com/open-telemetry/opentelemetry-js/tree/4a1f2e5fd441cc9c0359d6aaff1919d9c6672682/packages/opentelemetry-instrumentation>opentelemetry-js/packages/opentelemetry-instrumentation</a>, 至於如何去寫一個plugin則可以參考 <a href=https://reachmnadeem.wordpress.com/2021/02/22/opentelemetry-automatic-instrumentation-of-a-nodejs-library/>這篇</a></p><p>基本的plugin大致上像這樣:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#66d9ef>type</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>mssql</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;mypackage&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>InstrumentationBase</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>InstrumentationConfig</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>InstrumentationModuleDefinition</span>,
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@opentelemetry/instrumentation&#39;</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>InstrumentationConfig</span> ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MYPlugin</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>InstrumentationBase</span>&lt;<span style=color:#f92672>typeof</span> <span style=color:#a6e22e>mypackage</span>&gt; {
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>init</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>InstrumentationModuleDefinition</span>&lt;<span style=color:#f92672>any</span>&gt; <span style=color:#f92672>|</span> <span style=color:#a6e22e>InstrumentationModuleDefinition</span>&lt;<span style=color:#f92672>any</span>&gt;[] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Method not implemented.&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Plugin必須繼承自InstrumentationBase, 最好的範例應該是 <a href=https://github.com/open-telemetry/opentelemetry-js/blob/4a1f2e5fd441cc9c0359d6aaff1919d9c6672682/packages/opentelemetry-instrumentation-http/src/http.ts>http的instrumentation的實作</a>, 在這裏面, 你會看到像是:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_wrap</span>(
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>module</span><span style=color:#a6e22e>Exports</span>,
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#39;request&#39;</span>,
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_getPatchOutgoingRequestFunction</span>(<span style=color:#e6db74>&#39;http&#39;</span>)
</span></span><span style=display:flex><span>        );
</span></span></code></pre></div><p>這目的就是為了把原本的函數替換成包裝過有插追蹤碼的程式, 原理其實很容易理解, 而它是用了 <a href=https://github.com/othiym23/shimmer/>shimmer</a> 這個package, 來達到這個替換的目的, 實際上去看 <a href=https://github.com/othiym23/shimmer/>shimmer</a>, 也並不是一個很複雜的做法就是了</p><p>本來我是考慮寫一個plugin來處理Thrift client的部分, 原本的考量點是, 由於 <a href=https://github.com/othiym23/shimmer/>shimmer</a> 需要先知道method的名字才能替代, 所以 <code>hello</code>, <code>send_hello</code>, <code>recv_hello</code> 就不適合用來做包裝, 畢竟要做也是要做一個通用的, 不然試作後, 單純包裝 <code>hello</code> 其實算容易 (在呼叫原版本hello前先startSpan, 並把span.end包裝到回傳的Promise), 所以適合用在這邊的可能是包裝 <code>TProtocol.writeMessageBegin</code>, <code>TProtocol.readMessageBegin</code> ,不過這邊一直弄不成功, 可能也沒搞很懂instrumentation plugin, 後來又發現更簡便的做法就先放棄</p><h2 id=從-thift-generator-下手>從 thift generator 下手</h2><p>在用 <a href=https://github.com/othiym23/shimmer/>shimmer</a> 包裝 <code>hello</code> 時, 發現了一個問題, 由於我是用 typescript 而非javascript 在做這個實驗, typescript會去做型別檢查, 本來Javascript版本的 <code>hello</code> 的回傳是Promise, 但我在定義wrapped function的時候, 回傳型別設成
<code>Promise&lt;string></code> 則是會報錯, 結果實際上去看產生的程式碼:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>Int64</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>Int64</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>;
</span></span></code></pre></div><p>這完全是錯的, 也就是由Apache thrift這個工具產生的typescript是有問題的</p><p>想到在Scala中, 產生Thrift相關程式碼是用scrooge並不會去用官方Apache thrift的工具, typescript會不會也有像scrooge這工具? 結果就找到了<a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>creditkarma/thrift-typescript</a></p><p>這個專案也是蠻有趣的, 它是透過 <a href=https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API>Typescript compiler API</a>, 把Thrift IDL完全轉成typescript程式碼, 跟官方工具不同的地方是, 它產生的是純typecsript實做, 而非javascript實做搭配typescript定義, 因此產生的程式碼也好讀多了</p><p>所以我想, 何必一定糾結在auto instrumentation, 從code generator 去修改也是一個可行的做法, 要做到這件事, 那就要先看看, 我們預期它產生怎樣的程式碼, 於是我就去修改產生的程式碼來實驗, 像這樣:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Client</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>_seqid</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>_reqs</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>number</span>]<span style=color:#f92672>:</span> (<span style=color:#a6e22e>err</span>: <span style=color:#66d9ef>Error</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>object</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>, <span style=color:#a6e22e>val?</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>output</span>: <span style=color:#66d9ef>thrift.TTransport</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>new</span> (<span style=color:#a6e22e>trans</span>: <span style=color:#66d9ef>thrift.TTransport</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>TProtocol</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>tracer</span>:<span style=color:#66d9ef>opentelemetry.Tracer</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>serverSupportTracing</span>: <span style=color:#66d9ef>boolean</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>output</span>: <span style=color:#66d9ef>thrift.TTransport</span>, <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>new</span> (<span style=color:#a6e22e>trans</span>: <span style=color:#66d9ef>thrift.TTransport</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>TProtocol</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_seqid</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_reqs</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>output</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>output</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>protocol</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>protocol</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tracer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>opentelemetry</span>.<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>getTracer</span>(<span style=color:#e6db74>&#39;SampleServiceClient&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverSupportTracing</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>incrementSeqId</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_seqid</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>Int64</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>Int64</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>requestId</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>incrementSeqId</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>span</span>:<span style=color:#66d9ef>opentelemetry.Span</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tracer</span>.<span style=color:#a6e22e>startSpan</span>(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt;((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_reqs</span>[<span style=color:#a6e22e>requestId</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>error</span>, <span style=color:#a6e22e>result</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_reqs</span>[<span style=color:#a6e22e>requestId</span>];
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>error</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>result</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>end</span>();
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>send_hello</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>requestId</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這一段程式碼是截自 <a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>creditkarma/thrift-typescript</a> 從我的IDL產生的程式碼, 加上了tracer跟span, <code>startSpan</code>和<code>span.end</code>就插在hello裡面</p><p>這一段先用手工插入實驗後沒問題, 接下來我們就可以去改 <a href=https://github.com/open-telemetry/opentelemetry-js-contrib/tree/main/plugins/node>creditkarma/thrift-typescript</a> 讓程式自動去產生</p><p>由於這邊牽涉多一點, 我就不一一解釋, 貼上我修改的<a href=https://github.com/julianshen/thrift-typescript/commit/5f2ebeb85f6e639be11d5184f5470ca8d4d466b9>commit</a>, 大家有興趣可以參考 : <a href=https://github.com/julianshen/thrift-typescript/commit/5f2ebeb85f6e639be11d5184f5470ca8d4d466b9>https://github.com/julianshen/thrift-typescript/commit/5f2ebeb85f6e639be11d5184f5470ca8d4d466b9</a></p><p>這樣一來, 產生我們要的client code就沒啥問題了</p><h2 id=傳遞追蹤資訊>傳遞追蹤資訊</h2><p>前面有提到<a href=https://twitter.github.io/finagle/>Finagle</a>有支援Zipkin Tracing, 只有client和server都是Finagle才可以在Thrift間傳遞追蹤資訊, 那實際上Finagle又是怎做的呢? 它的做法是在Thrift的通訊協定上做了一些小修改, 先來看看底下這三張圖</p><p><img src=/images/posts/twitterthrift.drawio.png alt="Twitter Thrift"></p><p>第一張是通常狀況, 在兩端都不支援傳遞追蹤資訊, 或是Client不支援, 就是走正常的路線, 第二三張則是在Client有支援(Finagle client), client會先送<code>__can__finagle__trace__v3__</code>這個呼叫確認server有支援, server如果有支援的話, 就會回傳正確的結果, 如果沒支援則會是 <code>UNKNOW_METHOD</code></p><p>Client在確認server有支援後, 後面的request就會先多帶一個header包含Tracing相關的資訊了</p><p>這部分, 我目前也只實做go版本的server, client版本尚未做, 這邊會需要做的部份包含:</p><ol><li>呼叫 <code>__can__finagle__trace__v3__</code> 確認是否支援tracing</li><li>將client端的tracing資訊帶入相關的header中</li></ol><p>如果client是用OpenTelemetry, 而server這邊是用Finagle加zipkin的話, 就得要注意Trace ID, Span ID的轉換, 這兩邊用的長度跟型別有點不太一樣, 轉換的範例如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UInt64ToTraceID</span>(<span style=color:#a6e22e>high</span>, <span style=color:#a6e22e>low</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#a6e22e>pdata</span>.<span style=color:#a6e22e>TraceID</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>traceID</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>16</span>]<span style=color:#66d9ef>byte</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>PutUint64</span>(<span style=color:#a6e22e>traceID</span>[:<span style=color:#ae81ff>8</span>], <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>PutUint64</span>(<span style=color:#a6e22e>traceID</span>[<span style=color:#ae81ff>8</span>:], <span style=color:#a6e22e>low</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pdata</span>.<span style=color:#a6e22e>NewTraceID</span>(<span style=color:#a6e22e>traceID</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(Source: <a href=https://github.com/open-telemetry/opentelemetry-collector/blob/6ae558c8757cad4ed29f7c9496b38827990f156f/internal/idutils/big_endian_converter.go#L24>https://github.com/open-telemetry/opentelemetry-collector/blob/6ae558c8757cad4ed29f7c9496b38827990f156f/internal/idutils/big_endian_converter.go#L24</a>)</p><p>只要在把這整段整合到code generator, 應該就可以大功告成了</p><p>雖然一開始覺得是個小題目, 沒想到居然讓我用這麼大篇幅介紹, 而且全部實做還沒完成, 看來是有點太過低估了</p></div></article><div class=pagination><ul class=inline-list><li><a href=/page/3/ class=btn>Previous</a></li><li><a href=/>1</a></li><li><a href=/page/2/>2</a></li><li><a href=/page/3/>3</a></li><li><strong class=current-page>4</strong></li><li><a href=/page/5/>5</a></li><li><a href=/page/6/>6</a></li><li><a href=/page/7/>7</a></li><li><a href=/page/8/>8</a></li><li><a href=/page/9/>9</a></li><li><a href=/page/10/>10</a></li><li><a href=/page/11/>11</a></li><li><a href=/page/12/>12</a></li><li><a href=/page/13/>13</a></li><li><a href=/page/14/>14</a></li><li><a href=/page/15/>15</a></li><li><a href=/page/16/>16</a></li><li><a href=/page/17/>17</a></li><li><a href=/page/18/>18</a></li><li><a href=/page/19/>19</a></li><li><a href=/page/20/>20</a></li><li><a href=/page/21/>21</a></li><li><a href=/page/22/>22</a></li><li><a href=/page/23/>23</a></li><li><a href=/page/24/>24</a></li><li><a href=/page/25/>25</a></li><li><a href=/page/26/>26</a></li><li><a href=/page/27/>27</a></li><li><a href=/page/28/>28</a></li><li><a href=/page/29/>29</a></li><li><a href=/page/30/>30</a></li><li><a href=/page/31/>31</a></li><li><a href=/page/32/>32</a></li><li><a href=/page/33/>33</a></li><li><a href=/page/34/>34</a></li><li><a href=/page/35/>35</a></li><li><a href=/page/36/>36</a></li><li><a href=/page/37/>37</a></li><li><a href=/page/38/>38</a></li><li><a href=/page/39/>39</a></li><li><a href=/page/40/>40</a></li><li><a href=/page/41/>41</a></li><li><a href=/page/42/>42</a></li><li><a href=/page/43/>43</a></li><li><a href=/page/44/>44</a></li><li><a href=/page/45/>45</a></li><li><a href=/page/46/>46</a></li><li><a href=/page/47/>47</a></li><li><a href=/page/48/>48</a></li><li><a href=/page/49/>49</a></li><li><a href=/page/50/>50</a></li><li><a href=/page/51/>51</a></li><li><a href=/page/52/>52</a></li><li><a href=/page/53/>53</a></li><li><a href=/page/54/>54</a></li><li><a href=/page/55/>55</a></li><li><a href=/page/56/>56</a></li><li><a href=/page/57/>57</a></li><li><a href=/page/58/>58</a></li><li><a href=/page/59/>59</a></li><li><a href=/page/60/>60</a></li><li><a href=/page/61/>61</a></li><li><a href=/page/62/>62</a></li><li><a href=/page/63/>63</a></li><li><a href=/page/64/>64</a></li><li><a href=/page/65/>65</a></li><li><a href=/page/66/>66</a></li><li><a href=/page/67/>67</a></li><li><a href=/page/68/>68</a></li><li><a href=/page/69/>69</a></li><li><a href=/page/70/>70</a></li><li><a href=/page/71/>71</a></li><li><a href=/page/72/>72</a></li><li><a href=/page/73/>73</a></li><li><a href=/page/74/>74</a></li><li><a href=/page/75/>75</a></li><li><a href=/page/76/>76</a></li><li><a href=/page/5/ class=btn>Next</a></li></ul></div></div><div class=footer-wrapper><footer role=contentinfo><span>Powered by <a href=https://gohugo.io/ rel=nofollow>Hugo</a> using the <a href=https://github.com/dldx/hpstr-hugo-theme rel=nofollow>HPSTR theme</a>.</span></footer></div><script src=//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js></script>
<script src=https://kit.fontawesome.com/872a53b461.js crossorigin=anonymous></script>
<script>window.jQuery||document.write('<script src="/js/vendor/jquery-1.9.1.min.js"><\/script>')</script><script src=/js/scripts.min.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-79243751-1","auto"),ga("send","pageview"))</script><div id=fb-root></div><script async defer crossorigin=anonymous src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v7.0&appId=293999444006555&autoLogAppEvents=1" nonce=geZSUIUh></script></body></html>