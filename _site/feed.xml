<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.6">Jekyll</generator><link href="http://blog.jln.co/feed.xml" rel="self" type="application/atom+xml" /><link href="http://blog.jln.co/" rel="alternate" type="text/html" /><updated>2016-06-15T23:45:59+08:00</updated><id>http://blog.jln.co/</id><title>Le murmure de Julian</title><subtitle>朱隸安貓囈語錄</subtitle><entry><title>[筆記] 移植Parse Push</title><link href="http://blog.jln.co/%E7%AD%86%E8%A8%98-%E7%A7%BB%E6%A4%8Dparse-push/" rel="alternate" type="text/html" title="[筆記] 移植Parse Push" /><published>2016-02-25T01:13:36+08:00</published><updated>2016-02-25T01:13:36+08:00</updated><id>http://blog.jln.co/筆記-移植parse-push</id><content type="html" xml:base="http://blog.jln.co/%E7%AD%86%E8%A8%98-%E7%A7%BB%E6%A4%8Dparse-push/">&lt;p&gt;今天追完了綠箭, 該來點功課, 不過今天忘了買啤酒了:(&lt;/p&gt;

&lt;p&gt;Parse Push, 這功能無疑應該是Parse本身比較受歡迎的部分, 既然Parse明年要關門大吉了,這部份也是必須要搬家的, 但搬家比較麻煩的不是要搬到哪去, 而是之前累積的使用者, 總不希望一搬了就找不到他們了, Parse Push支援了包含了Google的GCM和Apple的APNS,以及他們自己的PPNS,以GCM來說, 在_Installation裡面, Parse是有儲存了GCM的deviceToken, 如果你之前用的是自己的GCM Sender ID, 那這部份直接搬了就可以用了, 但如果不是, 那預設用的是Parse自己的, 這樣這些deviceToken就不能夠使用自己的Sender ID來送, 必須要用用下面的方法來補救:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;從Google的&lt;a href=&quot;https://console.developers.google.com/&quot;&gt;Developer console&lt;/a&gt;取的Sender ID跟API Key&lt;/li&gt;
&lt;li&gt;在AndroidManifest.xml加入 &lt;code&gt;&amp;lt;meta-data android:name=&quot;com.parse.push.gcm_sender_id&quot; android:value=&quot;id:12345678&quot;&amp;gt;&lt;/code&gt; (必須要以&amp;quot;id:&amp;ldquo;加上你的sender id)&lt;/li&gt;
&lt;li&gt;發布新的升級到Play store&lt;/li&gt;
&lt;li&gt;使用者更新後至少發送一次Push (如果你在Application中有去儲存Installation, 這時候因為有了新的sender, 所以deviceToken會被更新)&lt;/li&gt;
&lt;li&gt;可以用你自己的API key送給新的device token了(可以不用透過Parse console去送, 也可以用其他程式)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;這個Go的範例可以用來試驗送PUSH到你的手機上:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/julianshen/90a7b5c4a24eb13f41fa.js&quot;&gt;&lt;/script&gt;&lt;p&gt;找出你手機的deviceToken後即可用這個來驗證是否能夠成功送出push&lt;/p&gt;

&lt;p&gt;但這樣還不夠, 我們還需要一個負責幫我們送push的server, 在之前那篇&lt;a href=&quot;http://blog.jln.co/post/139174339467/%E7%AD%86%E8%A8%98-parse-%E8%87%AA%E6%95%91%E6%96%B9%E6%A1%88%E4%B9%8B%E4%B8%80-pushd&quot;&gt;Parse自救方案&lt;/a&gt;裡有提到一個Pushd, 這是其中一個作法, 不過需要改一些東西才可以符合Parse Android SDK接收的格式, 另一個作法是透過open source的&lt;a href=&quot;https://github.com/ParsePlatform/parse-server/&quot;&gt;Parse Server&lt;/a&gt;, 原本它剛一出來時, 並沒支援Push, 但後來有其他人幫它加了上去了, 但它的方式是提供了API給你送PUSH, 但一來把API server跟PUSH server放一起並不是件好事, 二來當送大量的PUSH這樣的設計並不保險(並沒有queue, 送到一半server死了就麻煩了)&lt;/p&gt;

&lt;p&gt;不過要以Parse server的為基礎拆出push的部分也不是很難, 做了一個簡單的範例: &lt;a href=&quot;https://github.com/julianshen/parse_push_js&quot;&gt;github.com/julianshen/parse_push_js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在這範例裡, 使用了Parse Server的ParsePushAdapter, 並且利用了Redis當作queue來做成的簡單的push server, 這樣應該就加減堪用了, 不過這邊有一個還需要再改的是, ParsePushAdapter 並不會把產生的push id回傳到上一層, 這樣要做追蹤紀錄其實有點比較不方便, 這邊還需要再加強一下&lt;/p&gt;</content><summary>今天追完了綠箭, 該來點功課, 不過今天忘了買啤酒了:(</summary></entry><entry><title>[筆記] 被冤枉的MongoDB</title><link href="http://blog.jln.co/%E7%AD%86%E8%A8%98-%E8%A2%AB%E5%86%A4%E6%9E%89%E7%9A%84mongodb/" rel="alternate" type="text/html" title="[筆記] 被冤枉的MongoDB" /><published>2016-02-18T09:23:42+08:00</published><updated>2016-02-18T09:23:42+08:00</updated><id>http://blog.jln.co/筆記-被冤枉的mongodb</id><content type="html" xml:base="http://blog.jln.co/%E7%AD%86%E8%A8%98-%E8%A2%AB%E5%86%A4%E6%9E%89%E7%9A%84mongodb/">&lt;p&gt;續&lt;a href=&quot;http://blog.jln.co/post/139117302737/%E7%AD%86%E8%A8%98-deploy-mongodb-replica-set-to-coreosfleet&quot;&gt;前篇&lt;/a&gt; 裝好了MongoDB的Cluster後(1 Primary, 2 Secondaries)就開始進行大量的資料移轉&lt;/p&gt;

&lt;p&gt;結果資料寫到一半, 突然發現Primary換人了, 雖然因為有Secondaries, 會有人上來替代, 因為Mongo只有Primary才可以被寫入, 這使得client必須重新建立對新的primary的connection, 一度以為機器被reboot了, 但查logs並沒這現象, 後來又以為, MongoDB也太不濟了吧, 這種量級的寫入居然可以擊倒它, 結果後來查了log發現, 他的確被restart了, 只是兇手不是他, 是別人叫他去死的&lt;/p&gt;

&lt;p&gt;一切是Fleet惹的禍, 根據這篇&lt;a href=&quot;https://github.com/coreos/fleet/issues/1289&quot;&gt;Fleet engine stops units when etcd leadership change or has connectivity issues #1289&lt;/a&gt;, Fleet只要聯絡不到etcd, 就會認為不能獨活了, 就會把其他人也給殺了(可惡的殺人兇手),追根據底就是timeout設的太短了, 以至於當系統稍微(只是稍微而已)一忙, 就很容易超過timeout, 然後他就認為, 他的情人死了!(也太玻璃心了)&lt;/p&gt;

&lt;p&gt;解決方案就是延長timeout, 修改cloud-config加上如下的東西(把etcd的heartbeat跟election timeout延長, 把fleet相關的也給延長):&lt;/p&gt;

&lt;pre&gt;

#cloud-config

coreos:
  etcd2:
    heartbeat-interval: 600
    election-timeout: 6000
  fleet:
    engine-reconcile-interval: 10
    etcd-request-timeout: 5
    agent-ttl: 120s

&lt;/pre&gt;

&lt;p&gt;至於Azure上裝的coreos, cloud-config位置是在: &lt;code&gt;/var/lib/waagent/CustomData&lt;/code&gt;, 改完restart機器就好&lt;/p&gt;</content><summary>續前篇 裝好了MongoDB的Cluster後(1 Primary, 2 Secondaries)就開始進行大量的資料移轉</summary></entry><entry><title>[筆記] Parse 自救方案之一 - Pushd</title><link href="http://blog.jln.co/%E7%AD%86%E8%A8%98-parse-%E8%87%AA%E6%95%91%E6%96%B9%E6%A1%88%E4%B9%8B%E4%B8%80-pushd/" rel="alternate" type="text/html" title="[筆記] Parse 自救方案之一 - Pushd" /><published>2016-02-12T23:41:25+08:00</published><updated>2016-02-12T23:41:25+08:00</updated><id>http://blog.jln.co/筆記-parse-自救方案之一-pushd</id><content type="html" xml:base="http://blog.jln.co/%E7%AD%86%E8%A8%98-parse-%E8%87%AA%E6%95%91%E6%96%B9%E6%A1%88%E4%B9%8B%E4%B8%80-pushd/">&lt;p&gt;Parse自從宣布要收掉後, 雖然也放出open source的仿製品&lt;a href=&quot;https://github.com/ParsePlatform/parse-server&quot;&gt;Parse Server&lt;/a&gt;, 這東西不是實際上Parse真正跑得那個app server, 而是一個nodejs/express的相容版, 這個版本的故事可以看這邊 &lt;a href=&quot;https://medium.com/@newfosco/parse-2-0-600839abebdf#.vcv4l2lg2&quot;&gt;Parse 2.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;想當然爾, 這版本並不是完整支援Parse原本的功能, 尤其是Push, 這功能是完全沒有, 雖然說source codes放出來後, 大家熱烈的玩起來了, 最近幾天一個簡單的PUSH功能的pull request也被收錄進去了: &lt;a href=&quot;https://github.com/ParsePlatform/parse-server/pull/311&quot;&gt;Add support for push&lt;/a&gt;, 不過這畢竟比較陽春&lt;/p&gt;

&lt;p&gt;一些收費不收費的替代方案也不算少, 不過如果想自救, 自己建置自己管的話, 也是不用完全重來, &lt;a href=&quot;https://github.com/rs/pushd&quot;&gt;rs/pushd&lt;/a&gt; 這是目前看到還算蠻完整的, 採用了nodejs/coffee script + Redis, 在佈署方面也不算太難(不過也就兩個東西而已), 不過實際上的效能可能還是得測試一下(有沒好方法可以測大量的push呀?總不可能去生一堆機器)&lt;/p&gt;

&lt;p&gt;為了方便測試, 包裝成docker-compose.yml和一個方便使用的shell script: &lt;a href=&quot;https://github.com/julianshen/pushd-docker-compose-sample&quot;&gt;julianshen/pushd-docker-compose-sample&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用方法:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;修改&lt;code&gt;pushd.sh&lt;/code&gt;裡跟你的app相關的push設定如GCM_KEY&lt;/li&gt;
&lt;li&gt;執行&lt;code&gt;pushd.sh up&lt;/code&gt;啟動redis和pushd兩個containers&lt;/li&gt;
&lt;li&gt;執行&lt;code&gt;pushd.sh ps&lt;/code&gt;確認是不是兩個都已經正確啟動&lt;/li&gt;
&lt;li&gt;PUSHD的port是對應到host的8081, 所以直接對8081操作即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下來可能要想一些方法來測試, 和把Parse的資料給串一起&lt;/p&gt;</content><summary>Parse自從宣布要收掉後, 雖然也放出open source的仿製品Parse Server, 這東西不是實際上Parse真正跑得那個app server, 而是一個nodejs/express的相容版, 這個版本的故事可以看這邊 Parse 2.0</summary></entry><entry><title>[筆記] Deploy Mongodb replica set to coreos/fleet cluster on Azure</title><link href="http://blog.jln.co/%E7%AD%86%E8%A8%98-deploy-mongodb-replica-set-to-coreosfleet/" rel="alternate" type="text/html" title="[筆記] Deploy Mongodb replica set to coreos/fleet cluster on Azure" /><published>2016-02-12T00:34:07+08:00</published><updated>2016-02-12T00:34:07+08:00</updated><id>http://blog.jln.co/筆記-deploy-mongodb-replica-set-to-coreosfleet</id><content type="html" xml:base="http://blog.jln.co/%E7%AD%86%E8%A8%98-deploy-mongodb-replica-set-to-coreosfleet/">&lt;p&gt;把我過年假期試的先來紀錄一下，這篇基本上有兩個部分:&lt;/p&gt;

&lt;p&gt;第一部份是在Azure上部署一個coreos cluster，這部份可以參考以下幾篇：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://m.youtube.com/watch?v=wxUxtflalE4&quot;&gt;Scaling Docker #1 - High Availability Docker DevOps with CoreOS, Etcd, Fleet, Flannel &amp;amp; Nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/willrstern/production-docker-ha-architecture&quot;&gt;willrstern/production-docker-ha-architecture&lt;/a&gt; - 這是上一段影片用的source codes, 那段影片有好幾段, 講的蠻清楚的, 但是佈署在Digital Ocean上, 這邊我借用他的cloud-config&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://azure.microsoft.com/zh-tw/documentation/articles/virtual-machines-linux-coreos-how-to/&quot;&gt;如何在 Azure 上使用 CoreOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://azure.microsoft.com/zh-tw/documentation/articles/virtual-machines-linux-coreos-fleet-get-started/&quot;&gt;開始在 Azure 上的 CoreOS VM 叢集使用 Fleet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;這邊我使用的不是Azure的classic vm而是用了resource manager，這部份 可以參考這篇：
&lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/&quot;&gt;Deploy an application with Azure Resource Manager template&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要使用arm的話，首先要把模式切到arm:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;azure config mode arm&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下來得建立一個resource group:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;azure group create -n &amp;ldquo;group_name&amp;rdquo; -l &amp;ldquo;West US&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-n 後面是這個群組的名字, -l 後面則是它所在區域&lt;/p&gt;

&lt;p&gt;接下來可以利用resource group templates來建立相關的資源, resource group template 除了可以自己寫以外(參考這邊 &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/&quot;&gt;Authoring Azure Resource Manager templates&lt;/a&gt;), 也可以上&lt;a href=&quot;https://azure.microsoft.com/zh-tw/documentation/templates/&quot;&gt;Azure 快速入門範本去找現成的&lt;/a&gt;, 至於coreos + fleet, 就有一個現成的:&lt;a href=&quot;https://azure.microsoft.com/zh-tw/documentation/templates/coreos-with-fleet-multivm/&quot;&gt;Deploy a CoreOS cluster hosting Fleet&lt;/a&gt;, 它的&lt;a href=&quot;https://github.com/Azure/azure-quickstart-templates/tree/master/coreos-with-fleet-multivm&quot;&gt;source code在github上也可以找到&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本上應該是改一下azuredeploy.parameters.json再執行下面指令就可以:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;azure group deployment create GroupName DeploymentName &amp;ndash;template-file azuredeploy.json &amp;ndash;parameters-file azuredeploy.parameters.json&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而裡面的discovery url部分, 則是要去: &lt;a href=&quot;https://discovery.etcd.io/new?size=3&quot;&gt;https://discovery.etcd.io/new?size=3&lt;/a&gt; 產生一個貼上去&lt;/p&gt;

&lt;p&gt;但我前幾天在試的時候, 似乎它azuredeploy.json的換行有點問題(寫這篇文章時再看它已經是修正了), 以至於我執行起來有點問題, 再加上, 新的coreos stable似乎也改用etcd2取代原本的etcd, 因此我想要用另一個版本的cloud-config(即借用Scaling Docker那段影片裡用的那個cloud-config, 那個即是使用etcd2), 此外他的vm name也全是以coreos開頭的(我想要自己命名)&lt;/p&gt;

&lt;p&gt;因此, 我修改了一個自己的版本, 也放在github上: &lt;a href=&quot;https://github.com/julianshen/azure-core-fleet&quot;&gt;julianshen/azure-core-fleet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;這版本把cloud-config獨立成一個template而非寫死在azuredeploy.json, 並借用上面所述的版本, 並且寫了一隻&lt;em&gt;paramgen.go&lt;/em&gt;來產生azuredeploy.parameters.json, discovery url不用自己去產生, 這支程式會自動幫你取得, 用法:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;em&gt;go get github.com/parnurzeal/gorequest&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;go run paramgen.go &amp;ndash;numberOfNodes 3 &amp;ndash;location &amp;ldquo;East US&amp;rdquo; &amp;ndash;newStorageAccountName &amp;ldquo;mystorageaccount&amp;rdquo; &amp;ndash;vmSize &amp;ldquo;Standard_A1&amp;rdquo; &amp;ndash;adminUserName &amp;ldquo;admin&amp;rdquo; &amp;ndash;vmNamePrefix &amp;ldquo;myvm&amp;rdquo; &amp;ndash;sshKeyFile ~/.ssh/azure_rsa.pub&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;參數如下:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;numberOfNodes 要開的vm數量&lt;/li&gt;
&lt;li&gt;location vm位置(還是得跟你的resource group所在位置一樣)&lt;/li&gt;
&lt;li&gt;newStorageAccountName storage account name&lt;/li&gt;
&lt;li&gt;vmSize VM的大小&lt;/li&gt;
&lt;li&gt;adminUserName 管理者的名稱&lt;/li&gt;
&lt;li&gt;vmNamePrefix vm名字的開頭&lt;/li&gt;
&lt;li&gt;sshKeyFile ssk key的檔案位置(如果沒有,預設是~/.ssh/id_rsa.pub)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接著跑前面提到那段:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;azure group deployment create GroupName DeploymentName &amp;ndash;template-file azuredeploy.json &amp;ndash;parameters-file azuredeploy.parameters.json&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;執行結束後就會得到三頭牛, ㄟ,是三台VM(取決於numberOfNodes數目)及相關資源, 而且依據這個範本, 這三台VM跑得都會是coreos, 擁有我們指定的cloud-config, 這cloud-config會在coreos上啟用etcd2, fleet, 和flanneld (如Scaling Docker那段裡面的一樣)&lt;/p&gt;

&lt;p&gt;用ARM的模式的好處是,這三台VM會是在同一個虛擬網路上, 有各自的私有的IP, 當然也有各自的公開IP&lt;/p&gt;

&lt;p&gt;裝好後, 有碰到一個問題, 就是不知道為何, 重啟vm時, 會碰到etcd也跑起來了取代了etcd2, 而etcdctl 2.0.9又跟etcd有相容性問題, 導致fleet出問題, 因此在原本的cloud-config加上了:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;&lt;li&gt;name: etcd.service
    mask: true&lt;/li&gt;
  &lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;這樣一來etcd就不會去執行了&lt;/p&gt;

&lt;p&gt;再來就要測試剛剛的佈署是不是成功沒問題了&lt;/p&gt;

&lt;p&gt;首先我們需要fleetctl, 如果不希望登入vm就可以使用, 還是可以在本地端安裝, 在mac下可用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;brew install fleetctl&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然後要設定兩個環境變數:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;em&gt;export FLEETCTL_TUNNEL=xxx.xxx.xxx.xxx&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;export FLEETCTL_SSH_USERNAME=admin&lt;/em&gt; (你設定的admin user名字)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下來用:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;fleetctl list-machines&lt;/em&gt; &amp;ndash;full&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;會得到像這樣的結果:&lt;/p&gt;

&lt;pre&gt;
MACHINE     IP      METADATA
291c678da14841a7bec4c9aa0dfe168c    10.0.0.6    -
8e63696268c54a62a3f21043669997c6    10.0.0.4    -
fbc2675e0aa940e1b11eb6640b62906f    10.0.0.5    -
&lt;/pre&gt;

&lt;p&gt;這表示這三台vm已經都跑起來了, 如果我們要ssh連上第一台可以用這種方式:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;fleetctl ssh 291c678da14841a7bec4c9aa0dfe168c&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完全不用知道這台機器的public IP&lt;/p&gt;

&lt;p&gt;有了這三台VM, 接下來要做的事就是要deploy Mongodb的replica set了&lt;/p&gt;

&lt;p&gt;這邊我找到兩個參考:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/19hz/coreos-mongodb-cluster&quot;&gt;19hz/coreos-mongodb-cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/auth0/coreos-mongodb&quot;&gt;auth0/coreos-mongodb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一個其實是參考第二個寫出來的, 這兩個的差異在於第一個使用了data volume container&lt;/p&gt;

&lt;p&gt;Data volume container的優缺點及使用方法可以參考這篇: &lt;a href=&quot;https://docs.docker.com/engine/userguide/containers/dockervolumes/&quot;&gt;Manage data in containers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本來我想直接採用第一個的, 不過弄了半天, 每次都是在加好admin user後restart mongo時就失敗了, 加上他的方法其實沒辦法保證db container剛好跟data volume container一定在同一台機器(可以參考&lt;a href=&quot;https://github.com/19hz/coreos-mongodb-cluster/issues/2&quot;&gt;這一個issue&lt;/a&gt;), 後來就有點懶得看, 所以改採用第二個方法&lt;/p&gt;

&lt;p&gt;第二個方法還蠻簡單的:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;先ssh到任一台(可以用fleetctl ssh),用etcdctl設定這個變數: &lt;em&gt;etcdctl set /mongo/replica/name myreplica&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;執行 &lt;em&gt;fleetctl start mongo@{1..3}.service&lt;/em&gt; 以及 &lt;em&gt;fleetctl start  mongo-replica-config.service&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在第一個node跑起來後, 它會建立admin user自動產生它的密碼, 建立replica key, 然後再重啟mongodb, 相關參數像是admin user的密碼就會存在etcd, 會需要花一點時間&lt;/p&gt;

&lt;p&gt;用 &lt;code&gt;fleetctl list-units&lt;/code&gt; 就可以看各個的執行結果了, 像這樣&lt;/p&gt;

&lt;pre&gt;
UNIT                MACHINE         ACTIVE      SUB
mongo-replica-config.service    8e636962.../10.0.0.4    inactive    dead
mongo@1.service         8e636962.../10.0.0.4    active      running
mongo@2.service         291c678d.../10.0.0.6    active      running
mongo@3.service         fbc2675e.../10.0.0.5    active      running
&lt;/pre&gt;

&lt;p&gt;mongo-replica-config由於只會跑一次, 所以你會看到他最後的狀態是dead&lt;/p&gt;

&lt;p&gt;這裡建立出來的admin使用者為 &lt;em&gt;siteRootAdmin&lt;/em&gt; , 密碼則可以連上任一台, 用etcdctl取得:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;etcdctl get /mongo/replica/siteRootAdmin/pwd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有了這個後就可以遠端用mongodb cli或是相關的工具連上這台mongodb了&lt;/p&gt;

&lt;p&gt;心得: fleet在這邊的作用感覺並不是很大, 同樣的東西應該也可以用chef或ansible來佈署, 這邊沒太多異質性的服務需要部屬(也只有一個服務), 而且我常會有連不上的狀況, 不過它算是蠻簡單的, 下次應該來試試kubernetes或是docker swarm&lt;/p&gt;</content><summary>把我過年假期試的先來紀錄一下，這篇基本上有兩個部分:</summary></entry><entry><title>[iOS生手筆記] Swift練習曲之2 - SwSelect (快速生產抓圖神器)</title><link href="http://blog.jln.co/ios%E7%94%9F%E6%89%8B%E7%AD%86%E8%A8%98-swift%E7%B7%B4%E7%BF%92%E6%9B%B2%E4%B9%8B2-swselect-%E5%BF%AB%E9%80%9F%E7%94%9F%E7%94%A2%E6%8A%93%E5%9C%96%E7%A5%9E%E5%99%A8/" rel="alternate" type="text/html" title="[iOS生手筆記] Swift練習曲之2 - SwSelect (快速生產抓圖神器)" /><published>2015-10-05T23:37:39+08:00</published><updated>2015-10-05T23:37:39+08:00</updated><id>http://blog.jln.co/ios生手筆記-swift練習曲之2-swselect-快速生產抓圖神器</id><content type="html" xml:base="http://blog.jln.co/ios%E7%94%9F%E6%89%8B%E7%AD%86%E8%A8%98-swift%E7%B7%B4%E7%BF%92%E6%9B%B2%E4%B9%8B2-swselect-%E5%BF%AB%E9%80%9F%E7%94%9F%E7%94%A2%E6%8A%93%E5%9C%96%E7%A5%9E%E5%99%A8/">&lt;p&gt;既然講到抓圖神器, 就先幫友人Wisely宣傳一下: &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.wisely.imagedownloader&quot;&gt;https://play.google.com/store/apps/details?id=com.wisely.imagedownloader&lt;/a&gt;&lt;/p&gt;&lt;p&gt;不過在這並不是要宣傳抓圖神器的, 之前在找題目練習Swift時, 就想到要寫一個解析HTML的工具, 然後可以像是&lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;, 或是&lt;a href=&quot;https://github.com/PuerkitoBio/goquery&quot;&gt;goquery&lt;/a&gt;一樣方便, 至少用來解析網頁內的連結或圖片連結方便的, 比如說像是下面的code:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;let $ = SwSelect(html)&lt;br/&gt;let imgUrls = $(”img”).attrs(”src”)&lt;br/&gt;for url in imgUrls {&lt;br/&gt;    print(url)&lt;br/&gt;}&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;這個例子就這幾行就可以把網頁裡面圖片的Url給抓出來了, 又或, 如果我們只想抓某特定class的tag內包含的圖片(如：”&amp;lt;div class=“a1“&amp;gt;&amp;lt;img src=“aa.jpg”/&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=“a2″&amp;gt;&amp;lt;img src=“a2.jpg”/&amp;gt;&amp;lt;/div&amp;gt;” 我們只想要包含在a1裡面卻不想要a2裡面的就可以用:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;let $ = SwSelect(html)&lt;br/&gt;let imgUrls = $(”.a1″).find(”img”).attrs(”src”)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本來我是想學&lt;a href=&quot;https://github.com/PuerkitoBio/goquery&quot;&gt;goquery&lt;/a&gt;一樣, 複刻出一套&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;出來的, 順便複習一下&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, 上面的範例其實也像是&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;的API(不得不說這API還有selector設計真的是神來一筆), 因此選擇要把&lt;a href=&quot;https://github.com/PuerkitoBio/goquery&quot;&gt;goquery&lt;/a&gt;從golang po到swift來, 其實是蠻可行的, 因為這兩個語言相似度還蠻高的, 但做到一半發現, 要複製整個&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;其實蠻龐大的, 而且我只需要解析HTML的部分並不需要修改HTML的部分, 因此中途急轉彎, 把寫到一半的code, 重新包裝成這個&lt;a href=&quot;https://github.com/julianshen/SwSelect&quot;&gt;SwSelect&lt;/a&gt;, 剛好也足夠達到上面兩個例子想要的啦&lt;/p&gt;&lt;p&gt;由於原本就是想從goquery po過來,  因此包裝了libxml2, 也把goquery用的selector parser的核心 - &lt;a href=&quot;https://github.com/andybalholm/cascadia&quot;&gt;Cascadia&lt;/a&gt;給移植到Swift來, 整個&lt;a href=&quot;https://github.com/julianshen/SwSelect&quot;&gt;SwSelect&lt;/a&gt;可以說是基於&lt;a href=&quot;https://github.com/andybalholm/cascadia&quot;&gt;Cascadia&lt;/a&gt;, 這次也順便練習了Swift 2的一些新特色, 不過在整合libxml2上面也吃了些苦頭, 這以後有機會再寫, 目前其實應該可以使用了, 說明還沒補, Cathage的支援也還沒試過, 不過一些用法可以看一下Unit test來當範例:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/julianshen/SwSelect/blob/master/SwSelectTests/SwSelectTests.swift&quot;&gt;https://github.com/julianshen/SwSelect/blob/master/SwSelectTests/SwSelectTests.swift&lt;/a&gt;&lt;/p&gt;&lt;p&gt;這週應該會找時間補上說明&lt;/p&gt;&lt;p&gt;如果有需要的話歡迎拿去使用:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/julianshen/SwSelect&quot;&gt;https://github.com/julianshen/SwSelect&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;</content><category term="iOS Development" /><category term="Swift" /><summary>既然講到抓圖神器, 就先幫友人Wisely宣傳一下: https://play.google.com/store/apps/details?id=com.wisely.imagedownloader不過在這並不是要宣傳抓圖神器的, 之前在找題目練習Swift時, 就想到要寫一個解析HTML的工具, 然後可以像是jsoup, 或是goquery一樣方便, 至少用來解析網頁內的連結或圖片連結方便的, 比如說像是下面的code:let $ = SwSelect(html)let imgUrls = $(”img”).attrs(”src”)for url in imgUrls {    print(url)}這個例子就這幾行就可以把網頁裡面圖片的Url給抓出來了, 又或, 如果我們只想抓某特定class的tag內包含的圖片(如：”&amp;lt;div class=“a1“&amp;gt;&amp;lt;img src=“aa.jpg”/&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=“a2″&amp;gt;&amp;lt;img src=“a2.jpg”/&amp;gt;&amp;lt;/div&amp;gt;” 我們只想要包含在a1裡面卻不想要a2裡面的就可以用:let $ = SwSelect(html)let imgUrls = $(”.a1″).find(”img”).attrs(”src”)本來我是想學goquery一樣, 複刻出一套jQuery出來的, 順便複習一下jQuery, 上面的範例其實也像是jQuery的API(不得不說這API還有selector設計真的是神來一筆), 因此選擇要把goquery從golang po到swift來, 其實是蠻可行的, 因為這兩個語言相似度還蠻高的, 但做到一半發現, 要複製整個jQuery其實蠻龐大的, 而且我只需要解析HTML的部分並不需要修改HTML的部分, 因此中途急轉彎, 把寫到一半的code, 重新包裝成這個SwSelect, 剛好也足夠達到上面兩個例子想要的啦由於原本就是想從goquery po過來,  因此包裝了libxml2, 也把goquery用的selector parser的核心 - Cascadia給移植到Swift來, 整個SwSelect可以說是基於Cascadia, 這次也順便練習了Swift 2的一些新特色, 不過在整合libxml2上面也吃了些苦頭, 這以後有機會再寫, 目前其實應該可以使用了, 說明還沒補, Cathage的支援也還沒試過, 不過一些用法可以看一下Unit test來當範例:https://github.com/julianshen/SwSelect/blob/master/SwSelectTests/SwSelectTests.swift這週應該會找時間補上說明如果有需要的話歡迎拿去使用:https://github.com/julianshen/SwSelect</summary></entry><entry><title>[iOS生手筆記] Extending Arrays</title><link href="http://blog.jln.co/ios%E7%94%9F%E6%89%8B%E7%AD%86%E8%A8%98-extending-arrays/" rel="alternate" type="text/html" title="[iOS生手筆記] Extending Arrays" /><published>2015-10-04T23:47:48+08:00</published><updated>2015-10-04T23:47:48+08:00</updated><id>http://blog.jln.co/ios生手筆記-extending-arrays</id><content type="html" xml:base="http://blog.jln.co/ios%E7%94%9F%E6%89%8B%E7%AD%86%E8%A8%98-extending-arrays/">&lt;p&gt;在Swift裡, Protocol和Protocol extension是非常強悍的東西, 比起OO世界的Class, 其實是更加犀利, 在今年(2015)的WWDC有一場個人很推薦的&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015-408/&quot;&gt;&lt;i&gt;Protocol-Oriented Programming in Swift&lt;/i&gt;&lt;/a&gt; &lt;i&gt;, &lt;/i&gt;這場講的蠻精闢的, 熱門到後來加開了第二場, 今年我去WWDC, 我自己就兩場都去了, 回來又再回為了一次, 相當建議聽看看的:&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015-408/&quot;&gt;https://developer.apple.com/videos/play/wwdc2015-408/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;好, 這篇重點不是推薦這場演講&amp;hellip;.而是怎在Swift中去建立Array extension? 這好像沒什麼難的, 不就像下面這樣就可以了?&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;i&gt;extension Array {&lt;br/&gt;    func concat() -&amp;gt; String {&lt;br/&gt;        var str = &amp;ldquo;&amp;rdquo;&lt;br/&gt;        for i in self {&lt;br/&gt;            str += String(i)&lt;br/&gt;        }&lt;br/&gt;        return str&lt;br/&gt;    }&lt;br/&gt;}&lt;/i&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;沒錯, 這是最簡單的方式, 但其實有個問題, Array內的元件(element)是泛型, 也就可能是任意的型態, 以這個例子來說, 也有可能是無法轉成String的型態, 在這邊就有可能出問題, 因為這寫法會被套用到所有的Array型態去, 不管是String array, In array或其他, 但大部分現實的例子(也就是我手上在寫的東西剛好碰到的例子), 我們只希望延伸出的東西只被套用到某些特定的型態, 這時候就得加上”where”來解決這問題:&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/julianshen/bf4895ab31f4fbda09c4.js&quot;&gt;&lt;/script&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;以上面這例子, 雖然字串陣列跟整數陣列都有find這函式, 參數型態也一樣(Self.Generator.Element), 但這兩者的find的行為是不同的, 以字串陣列來說是找含有這一字串的, 而以整數陣列來說則是找一樣的, 這邊就是靠extension裡的where&lt;/p&gt;&lt;p&gt;這邊有個不一樣的地方是, Array被換成CollectionType了, 這是因為where裡面要判斷Element是不是我們所要的型態, 而Array是一個struct, CollectionType才是一個Protocol, 所以這邊我們用CollectionType來達到這目的&lt;br/&gt;&lt;/p&gt;</content><category term="swift" /><category term="iOS Development" /><summary>在Swift裡, Protocol和Protocol extension是非常強悍的東西, 比起OO世界的Class, 其實是更加犀利, 在今年(2015)的WWDC有一場個人很推薦的Protocol-Oriented Programming in Swift , 這場講的蠻精闢的, 熱門到後來加開了第二場, 今年我去WWDC, 我自己就兩場都去了, 回來又再回為了一次, 相當建議聽看看的:https://developer.apple.com/videos/play/wwdc2015-408/好, 這篇重點不是推薦這場演講&amp;hellip;.而是怎在Swift中去建立Array extension? 這好像沒什麼難的, 不就像下面這樣就可以了?extension Array {    func concat() -&amp;gt; String {        var str = &amp;ldquo;&amp;rdquo;        for i in self {            str += String(i)        }        return str    }}沒錯, 這是最簡單的方式, 但其實有個問題, Array內的元件(element)是泛型, 也就可能是任意的型態, 以這個例子來說, 也有可能是無法轉成String的型態, 在這邊就有可能出問題, 因為這寫法會被套用到所有的Array型態去, 不管是String array, In array或其他, 但大部分現實的例子(也就是我手上在寫的東西剛好碰到的例子), 我們只希望延伸出的東西只被套用到某些特定的型態, 這時候就得加上”where”來解決這問題:以上面這例子, 雖然字串陣列跟整數陣列都有find這函式, 參數型態也一樣(Self.Generator.Element), 但這兩者的find的行為是不同的, 以字串陣列來說是找含有這一字串的, 而以整數陣列來說則是找一樣的, 這邊就是靠extension裡的where這邊有個不一樣的地方是, Array被換成CollectionType了, 這是因為where裡面要判斷Element是不是我們所要的型態, 而Array是一個struct, CollectionType才是一個Protocol, 所以這邊我們用CollectionType來達到這目的</summary></entry><entry><title>[iOS生手筆記] Swift裡的“\r”與”\r ”</title><link href="http://blog.jln.co/ios%E7%94%9F%E6%89%8B%E7%AD%86%E8%A8%98-swift%E8%A3%A1%E7%9A%84r%E8%88%87rn/" rel="alternate" type="text/html" title="[iOS生手筆記] Swift裡的“\r”與”\r\n”" /><published>2015-09-28T01:33:13+08:00</published><updated>2015-09-28T01:33:13+08:00</updated><id>http://blog.jln.co/ios生手筆記-swift裡的r與rn</id><content type="html" xml:base="http://blog.jln.co/ios%E7%94%9F%E6%89%8B%E7%AD%86%E8%A8%98-swift%E8%A3%A1%E7%9A%84r%E8%88%87rn/">&lt;p&gt;實在有點詭異的問題, 解決後又覺得實在有點蠢, 結果這問題足足花了我一個半小時才得到答案&lt;/p&gt;&lt;p&gt;問題是這樣的, 我拿了這一個字串 &lt;i&gt;&lt;b&gt;&amp;ldquo;&amp;lsquo;x\\r\nx&amp;rsquo;&amp;rdquo;&lt;/b&gt;&lt;/i&gt; 來做解析, 一個個Character去檢查是不是”\r”, 如:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;i&gt;let x=&amp;ldquo;&#39;x\\r\nx&amp;rsquo;&amp;rdquo;&lt;br/&gt;for s in x.characters {&lt;br/&gt;    if s == “\r” {&lt;br/&gt;         print(”got you!”)&lt;br/&gt;    }&lt;br/&gt;}&lt;/i&gt;&lt;br/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;邏輯上看起來沒啥問題, 但執行結果一直不如預期(沒印出”got you”), 把第四個字元substring出來它也不等於字串”\r”&lt;/p&gt;&lt;p&gt;百思不得其解, 結果最後在\r\n中間加一個空白後, 就得到預期的結果了, 原來&amp;hellip;.它是把”\r\n”整個當成一個字元!!!&lt;/p&gt;</content><category term="iOS Development" /><category term="Swift" /><summary>實在有點詭異的問題, 解決後又覺得實在有點蠢, 結果這問題足足花了我一個半小時才得到答案問題是這樣的, 我拿了這一個字串 &amp;ldquo;&amp;lsquo;x\\r x&amp;rsquo;&amp;rdquo; 來做解析, 一個個Character去檢查是不是”\r”, 如:let x=&amp;ldquo;&#39;x\\r x&amp;rsquo;&amp;rdquo;for s in x.characters {    if s == “\r” {         print(”got you!”)    }}邏輯上看起來沒啥問題, 但執行結果一直不如預期(沒印出”got you”), 把第四個字元substring出來它也不等於字串”\r”百思不得其解, 結果最後在\r 中間加一個空白後, 就得到預期的結果了, 原來&amp;hellip;.它是把”\r ”整個當成一個字元!!!</summary></entry><entry><title>[開箱文] Sentri初體驗</title><link href="http://blog.jln.co/%E9%96%8B%E7%AE%B1%E6%96%87-sentri%E5%88%9D%E9%AB%94%E9%A9%97/" rel="alternate" type="text/html" title="[開箱文] Sentri初體驗" /><published>2015-09-26T03:30:05+08:00</published><updated>2015-09-26T03:30:05+08:00</updated><id>http://blog.jln.co/開箱文-sentri初體驗</id><content type="html" xml:base="http://blog.jln.co/%E9%96%8B%E7%AE%B1%E6%96%87-sentri%E5%88%9D%E9%AB%94%E9%A9%97/">&lt;figure data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; src=&quot;http://66.media.tumblr.com/2d31d9c77645bf21f41ff9a13343f256/tumblr_inline_nv8y6kTYwi1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Sentri這個產品之前在Kick starter上的熱門程度, 可說是台灣之光呀, 加上它又是有幾個優秀的前同事的加持, 因此一開始我就在Kick starter上下訂了, 直到昨天終於收到他了, 本來想說晚點再來寫這篇的, 不過現在也沒啥睡意, 就先來寫寫&lt;/p&gt;&lt;p&gt;可能是剛開始的第一個產品, 其實還有些未盡完善的地方吧, 也有可能有些我體驗還沒很充足, 這篇參考參考就好, 不用太認真 :P&lt;/p&gt;&lt;p&gt;&lt;b&gt;開箱&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; src=&quot;http://67.media.tumblr.com/55f694986540162c317f19b494b3ad35/tumblr_inline_nv8xniKapb1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; src=&quot;http://66.media.tumblr.com/1d0b23d6ad10a93ffdf361bc8c88c370/tumblr_inline_nv8xo2ZYbb1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-orig-width=&quot;2448&quot; data-orig-height=&quot;3264&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;2448&quot; data-orig-height=&quot;3264&quot; src=&quot;http://66.media.tumblr.com/edfbe8e079f5a21aba71a5fc3b2f9a55/tumblr_inline_nv8xqw4lyr1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-orig-width=&quot;2448&quot; data-orig-height=&quot;3264&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;2448&quot; data-orig-height=&quot;3264&quot; src=&quot;http://66.media.tumblr.com/f3b32ddf3e6ac1aa960b4be8714518bf/tumblr_inline_nv8xre0LpD1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;包裝外觀還蠻用心的, 不像一般台灣3C產品的草率, 裡面也用了不少泡綿做保護, 背面則是寫滿了一堆功能性的解說, 不過這部份我比較不喜歡, 密密麻麻的字, 其實不太會想去看, 或許有一些生動的圖示, 減少一半的文字會更好一點&lt;/p&gt;&lt;p&gt;一打開後, 它就方方正正的(啊本來就方的)躺在中間, 配件(不多)則是在下面, 下面還有很多多餘空間, 這樣剛剛好, 也不算浪費空間, 翻到背面, 有兩個孔是可以釘牆上的, 還有一個kickstand是可以讓你立在桌上, 前者的設計其實有點怪異, 因為它必須是要接著電源的, 一般牆上掛鐘的位子比較少有插座&lt;/p&gt;&lt;p&gt;隱藏在腳座後面的則有USB, 網路孔, 電源開關, 跟Reset, 電源開關的設計, 是”一根”, 形狀我是覺得怪怪的, 怎不是圓圓的按鈕, 或許我比較習慣那樣 XD 不過, reset那個孔, 也太小了吧, 穿針線的針不知道會不會也太粗&lt;/p&gt;&lt;p&gt;&lt;b&gt;軟體&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; src=&quot;http://67.media.tumblr.com/2de21d76f9b97e819e13dd7ac6c499d9/tumblr_inline_nv8y8kHGaG1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;一開機之後, 自然是要做設定, “Welcome Home”這段字, 看起來是特別溫馨 :D&lt;/p&gt;&lt;p&gt;而緊接著, 就是要設定網路跟註冊帳號, 這邊我碰到一個小小的bug, 起先我是接著Ethernet, 但忘了把另一頭接到Hub上, 然後又因為它還是提示我設定Wifi, 我就也設定了, 結果在註冊階段, 它一直說我沒連上Internet, 最後才發現網路線的狀況, 此時我並不是接上另一頭而是把它拔掉, 拔掉之後就可以連上了, 看起來它默認先走有線的, 但卻不會因為有線的連不上切換成Wifi&lt;/p&gt;&lt;p&gt;初始設定都是利用觸控螢幕操作, 輸入文字時我是覺得有點彆扭, 我是覺得, 如果家裡有Wifi, 手機又是連上同一個網路, 或許可以讓使用者在手機登入後就可以同步完設定了&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;3264&quot; data-orig-height=&quot;2448&quot; src=&quot;http://66.media.tumblr.com/ffd527ebcad717229899d1e5679b0449/tumblr_inline_nv8yigc6ww1qzg4zq_540.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首頁的操作介面很簡單&lt;/p&gt;&lt;p&gt;首先映入眼簾的當然就是時鐘跟幾個資訊, 向左滑是設定, 向右則是Alerts&lt;/p&gt;&lt;p&gt;攝影機是用來監控的, 也有動態偵測, 所以一開始就可以在Alerts看到我被偷拍到的照片(小偷是我?!), 比較像是一個有螢幕的Dropcam&lt;/p&gt;&lt;p&gt;設定上可以設Away Mode (開啟Alerts) 和 Home mode (關閉Alerts), 以及可以設定桌面主題, 美中不足的是不可以用自己照片(也沒辦法用camera拍), 手機上的app也沒辦法用自己的圖設定這塊&lt;/p&gt;&lt;p&gt;相機則可設定夜視模式, 除了開關還有自動, 但自動好像沒啥用處, 我把房間燈關了, 用手機遠端看, 還是一片黑暗, 但我設定成打開就可以:&lt;/p&gt;&lt;p&gt;夜視效果不錯&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width=&quot;1242&quot; data-orig-height=&quot;2208&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;1242&quot; data-orig-height=&quot;2208&quot; src=&quot;http://65.media.tumblr.com/6dccf73c889bec15d6cd72856598c22e/tumblr_inline_nv8z392BxU1qzg4zq_540.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;效能上, 有點失望, 隨便點功能都要等待1~2秒以上, 會以為沒反應, 然後它就又突然出來了, 可能硬體不夠好或是效能還沒調整好, 如以下影片:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://goo.gl/photos/SUog336k8cNyXZ5E6&quot;&gt;https://goo.gl/photos/SUog336k8cNyXZ5E6&lt;/a&gt;&lt;/p&gt;&lt;p&gt;另外一個小缺點是沒有夜晚模式, 我把燈關了後它還是很亮, 它不適合擺臥房呀!&lt;a href=&quot;https://goo.gl/photos/SUog336k8cNyXZ5E6&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;手機App&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我目前只測了iPhone, 但這App的介面實在不像iPhone介面, 也還有點陽春, 目前還沒試太多, 但碰到幾個待改進的跟BUG&lt;/p&gt;&lt;p&gt;手機上的設定似乎跟Sentri不是同步的, 比如說, 我已經在Sentri上設定我是用攝氏為單位, 但手機登入後, 還是華氏&lt;/p&gt;&lt;figure data-orig-width=&quot;1242&quot; data-orig-height=&quot;2208&quot; class=&quot;tmblr-full&quot;&gt;&lt;img data-orig-width=&quot;1242&quot; data-orig-height=&quot;2208&quot; src=&quot;http://66.media.tumblr.com/54ab9451b5323683caf1cd4d3f972c8b/tumblr_inline_nv8za0z37P1qzg4zq_540.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Alerts影片播放有會變成上圖那樣&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;小結&lt;/b&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;初感覺就比較像是有螢幕的Dropcam, 目前可顯示的資訊還不太多, 我也沒啥裝置可以跟他互動, 如果可以把它當一個比較大的Android Wear或許也會不錯, 不過目前對它還沒太多想法, 可能需要再多體驗一陣子&lt;br/&gt;&lt;/p&gt;</content><category term="開箱文" /><summary>Sentri這個產品之前在Kick starter上的熱門程度, 可說是台灣之光呀, 加上它又是有幾個優秀的前同事的加持, 因此一開始我就在Kick starter上下訂了, 直到昨天終於收到他了, 本來想說晚點再來寫這篇的, 不過現在也沒啥睡意, 就先來寫寫可能是剛開始的第一個產品, 其實還有些未盡完善的地方吧, 也有可能有些我體驗還沒很充足, 這篇參考參考就好, 不用太認真 :P開箱包裝外觀還蠻用心的, 不像一般台灣3C產品的草率, 裡面也用了不少泡綿做保護, 背面則是寫滿了一堆功能性的解說, 不過這部份我比較不喜歡, 密密麻麻的字, 其實不太會想去看, 或許有一些生動的圖示, 減少一半的文字會更好一點一打開後, 它就方方正正的(啊本來就方的)躺在中間, 配件(不多)則是在下面, 下面還有很多多餘空間, 這樣剛剛好, 也不算浪費空間, 翻到背面, 有兩個孔是可以釘牆上的, 還有一個kickstand是可以讓你立在桌上, 前者的設計其實有點怪異, 因為它必須是要接著電源的, 一般牆上掛鐘的位子比較少有插座隱藏在腳座後面的則有USB, 網路孔, 電源開關, 跟Reset, 電源開關的設計, 是”一根”, 形狀我是覺得怪怪的, 怎不是圓圓的按鈕, 或許我比較習慣那樣 XD 不過, reset那個孔, 也太小了吧, 穿針線的針不知道會不會也太粗軟體一開機之後, 自然是要做設定, “Welcome Home”這段字, 看起來是特別溫馨 :D而緊接著, 就是要設定網路跟註冊帳號, 這邊我碰到一個小小的bug, 起先我是接著Ethernet, 但忘了把另一頭接到Hub上, 然後又因為它還是提示我設定Wifi, 我就也設定了, 結果在註冊階段, 它一直說我沒連上Internet, 最後才發現網路線的狀況, 此時我並不是接上另一頭而是把它拔掉, 拔掉之後就可以連上了, 看起來它默認先走有線的, 但卻不會因為有線的連不上切換成Wifi初始設定都是利用觸控螢幕操作, 輸入文字時我是覺得有點彆扭, 我是覺得, 如果家裡有Wifi, 手機又是連上同一個網路, 或許可以讓使用者在手機登入後就可以同步完設定了首頁的操作介面很簡單首先映入眼簾的當然就是時鐘跟幾個資訊, 向左滑是設定, 向右則是Alerts攝影機是用來監控的, 也有動態偵測, 所以一開始就可以在Alerts看到我被偷拍到的照片(小偷是我?!), 比較像是一個有螢幕的Dropcam設定上可以設Away Mode (開啟Alerts) 和 Home mode (關閉Alerts), 以及可以設定桌面主題, 美中不足的是不可以用自己照片(也沒辦法用camera拍), 手機上的app也沒辦法用自己的圖設定這塊相機則可設定夜視模式, 除了開關還有自動, 但自動好像沒啥用處, 我把房間燈關了, 用手機遠端看, 還是一片黑暗, 但我設定成打開就可以:夜視效果不錯效能上, 有點失望, 隨便點功能都要等待1~2秒以上, 會以為沒反應, 然後它就又突然出來了, 可能硬體不夠好或是效能還沒調整好, 如以下影片:https://goo.gl/photos/SUog336k8cNyXZ5E6另外一個小缺點是沒有夜晚模式, 我把燈關了後它還是很亮, 它不適合擺臥房呀!手機App我目前只測了iPhone, 但這App的介面實在不像iPhone介面, 也還有點陽春, 目前還沒試太多, 但碰到幾個待改進的跟BUG手機上的設定似乎跟Sentri不是同步的, 比如說, 我已經在Sentri上設定我是用攝氏為單位, 但手機登入後, 還是華氏Alerts影片播放有會變成上圖那樣小結初感覺就比較像是有螢幕的Dropcam, 目前可顯示的資訊還不太多, 我也沒啥裝置可以跟他互動, 如果可以把它當一個比較大的Android Wear或許也會不錯, 不過目前對它還沒太多想法, 可能需要再多體驗一陣子</summary></entry><entry><title>[Golang] Streaming JSON Parser in Go</title><link href="http://blog.jln.co/golang-streaming-json-parser-in-go/" rel="alternate" type="text/html" title="[Golang] Streaming JSON Parser in Go" /><published>2015-09-13T16:55:55+08:00</published><updated>2015-09-13T16:55:55+08:00</updated><id>http://blog.jln.co/golang-streaming-json-parser-in-go</id><content type="html" xml:base="http://blog.jln.co/golang-streaming-json-parser-in-go/">&lt;p&gt;目前Json已經可以說是Internet上相當流行的格式了, 雖然說他缺點還算蠻多的, 但很多主流的程式語言都有成熟的parser可供使用,  在Golang則可利用內建的encoding/json這個package來達成&lt;/p&gt;&lt;p&gt;用“encoding/json”來解析Json其實很簡單, 基本上就是建立一個Decoder然後把json內容”解”到你對應的資料結構去, 可以參考這範例: &lt;a href=&quot;http://golang.org/pkg/encoding/json/#example_Decoder&quot;&gt;http://golang.org/pkg/encoding/json/#example_Decoder&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但在某些狀況下並不是很好的解法, 舉個例子來說, 我這兩天打算拿從&lt;a href=&quot;http://parse.com&quot;&gt;Parse&lt;/a&gt;那邊匯出的使用者資料來做一些處理, &lt;a href=&quot;http://parse.com&quot;&gt;Parse&lt;/a&gt;輸出給我的JSON檔大約長得像這樣: &lt;br/&gt;&lt;/p&gt;&lt;p&gt;{&lt;br/&gt;       results: [&lt;br/&gt;             {&lt;br/&gt;                  “objectId”:”zzreueaWq4″,&lt;br/&gt;                  “username”:”julian”,&lt;br/&gt;             }&lt;br/&gt;       ]&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;按照這定義寫出的程式碼就類似這樣:&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/julianshen/ba805faa6f2ff41fc139.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;但這有一個很大的問題, &lt;a href=&quot;http://parse.com&quot;&gt;Parse&lt;/a&gt;那邊輸出給我的Json檔就有400MB之多(二十多萬筆), 可想而知的, 這程式直接先因為out of memory炸掉了, Decode需要把所有內容載入到記憶體才做解析, 而且以這範例, 解析完的結果全部存到我們的資料結構內, 自然有這問題, 常常這種應用我們都不是很需要把所有內容在記憶體放一份, 而是來一個處理一個&lt;/p&gt;&lt;p&gt;這時候就需要用Streaming parser的作法來解決這問題了, Golang的Json package也有支援這一模式, 但這也是在最新的1.5之後才有支援這模式, 使用這方法, 程式可以改成如下:&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/julianshen/2416ee3dc15c7358340f.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;在這邊由於我只需要results這陣列的內容而已, 因此我先用Token找到第一個”[”(以這範例來說, 第一個”[”代表的就是results的陣列了), 之後就是用迴圈一個個去解些個別的User物件, 由於這20多萬筆資料, 我也只是要印出來而已, 我也不用特地用一個大的資料結構來存, 自然記憶體的問題就比較沒那麼吃緊&lt;/p&gt;</content><category term="golang" /><category term="software development" /><summary>目前Json已經可以說是Internet上相當流行的格式了, 雖然說他缺點還算蠻多的, 但很多主流的程式語言都有成熟的parser可供使用,  在Golang則可利用內建的encoding/json這個package來達成用“encoding/json”來解析Json其實很簡單, 基本上就是建立一個Decoder然後把json內容”解”到你對應的資料結構去, 可以參考這範例: http://golang.org/pkg/encoding/json/#example_Decoder但在某些狀況下並不是很好的解法, 舉個例子來說, 我這兩天打算拿從Parse那邊匯出的使用者資料來做一些處理, Parse輸出給我的JSON檔大約長得像這樣: {       results: [             {                  “objectId”:”zzreueaWq4″,                  “username”:”julian”,             }       ]}按照這定義寫出的程式碼就類似這樣:但這有一個很大的問題, Parse那邊輸出給我的Json檔就有400MB之多(二十多萬筆), 可想而知的, 這程式直接先因為out of memory炸掉了, Decode需要把所有內容載入到記憶體才做解析, 而且以這範例, 解析完的結果全部存到我們的資料結構內, 自然有這問題, 常常這種應用我們都不是很需要把所有內容在記憶體放一份, 而是來一個處理一個這時候就需要用Streaming parser的作法來解決這問題了, Golang的Json package也有支援這一模式, 但這也是在最新的1.5之後才有支援這模式, 使用這方法, 程式可以改成如下:在這邊由於我只需要results這陣列的內容而已, 因此我先用Token找到第一個”[”(以這範例來說, 第一個”[”代表的就是results的陣列了), 之後就是用迴圈一個個去解些個別的User物件, 由於這20多萬筆資料, 我也只是要印出來而已, 我也不用特地用一個大的資料結構來存, 自然記憶體的問題就比較沒那麼吃緊</summary></entry><entry><title>使用Go產生動態gif</title><link href="http://blog.jln.co/%E4%BD%BF%E7%94%A8go%E7%94%A2%E7%94%9F%E5%8B%95%E6%85%8Bgif/" rel="alternate" type="text/html" title="使用Go產生動態gif" /><published>2015-09-06T22:45:37+08:00</published><updated>2015-09-06T22:45:37+08:00</updated><id>http://blog.jln.co/使用go產生動態gif</id><content type="html" xml:base="http://blog.jln.co/%E4%BD%BF%E7%94%A8go%E7%94%A2%E7%94%9F%E5%8B%95%E6%85%8Bgif/">&lt;p&gt;最近在嘗試寫一些動態gif的應用, 所以就研究了一下怎用go去產生動態gif, 後來找到以下這篇:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://shogo82148.github.io/blog/2015/04/25/quantize-image-in-golang/&quot;&gt;&lt;b&gt;Go言語で画像の減色を行う&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;其實這篇已經寫的蠻完整的了, 不過由它是日文(有很多日文的技術文章其實還不錯), 所以我嘗試用我自己的方法用中文再闡釋一遍&lt;/p&gt;&lt;p&gt;要用輸出動態gif其實go就已經支援了, 使用EncodeAll即可:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://golang.org/pkg/image/gif/#EncodeAll&quot;&gt;https://golang.org/pkg/image/gif/#EncodeAll&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;不過, 仔細看一下GIF這個struct裡的那個Image陣列, 接受的是Paletted, 也就是附有調色盤的圖(色彩較少), 而現在大部分的圖片大多是全彩的, 因此, 需要先把全彩的圖轉成Paletted, 而這部份的作法是利用image.draw裡的Draw把全彩的圖畫到一個新的Paletted去:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;i&gt;palImg := image.NewPaletted(img.Bounds(), palette.WebSafe)&lt;br/&gt;draw.Draw(palImg, img.Bounds(), img, image.ZP, draw.Over) &lt;/i&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由於新創一個Paletted圖, 需要給它一個調色盤, 最簡單的方法是給它預設的調色盤, 在image.color.palette裡有兩個(plan9, web safe), 這邊採用了比較通用的Web safe, 最後輸出的結果如下:&lt;/p&gt;&lt;figure data-orig-width=&quot;640&quot; data-orig-height=&quot;427&quot; class=&quot;tmblr-full&quot;&gt;&lt;img src=&quot;http://67.media.tumblr.com/9b88d1a7933aac85f8272d6fbd88df62/tumblr_inline_nu9eppWVNP1qzg4zq_540.gif&quot; data-orig-width=&quot;640&quot; data-orig-height=&quot;427&quot;/&gt;&lt;/figure&gt;&lt;p&gt;呃, 好醜&amp;hellip;..不過這是一定的, web safe一是組比較通用標準的色盤, 但大多數的顏色跟原本的圖的色彩差異可能相當的大, draw.Draw是在調色盤找出相近色, 但有可能找出來這顏色差異就很大了&lt;/p&gt;&lt;p&gt;那怎麼辦?我們就必須對全彩影像找出最佳的調色盤, 從成千上萬色中找出適合的256種顏色, 這在影像處理技巧中有個叫Color quantization, 它就是用來處理這樣的狀況的&lt;/p&gt;&lt;p&gt;在image.draw裡也找到了一個Quantizer:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://golang.org/src/image/draw/draw.go?s=688:910#L17&quot;&gt;&lt;i&gt;&lt;a href=&quot;https://golang.org/src/image/draw/draw.go?s=688:910#L17&quot;&gt;https://golang.org/src/image/draw/draw.go?s=688:910#L17&lt;/a&gt;&lt;/i&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;不過看來這個Quantizer只有空殼(interface)並未有實作(也就是這樣我才去找到那篇日文的參考文章), 雖說, 實作一個median cut演算法不難, 但對懶人來說, 能有現成的當然最好, 從那篇參考文章中看到了, 有人幾經寫好的(更不錯的是已經實作了Quantizer) -&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/soniakeys/quant/&quot;&gt;https://github.com/soniakeys/quant/&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用它後, 先前得程式碼可以簡單的改成 -&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;i&gt;q := median.Quantizer(256) //256個顏色&lt;br/&gt;palImg := q.Image(img)&lt;/i&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;得到的結果會優很多:&lt;/p&gt;&lt;figure data-orig-width=&quot;640&quot; data-orig-height=&quot;427&quot; class=&quot;tmblr-full&quot;&gt;&lt;img src=&quot;http://66.media.tumblr.com/da3e36284534036f4d04037cfdfe7832/tumblr_inline_nu9f9iyr0g1qzg4zq_540.gif&quot; data-orig-width=&quot;640&quot; data-orig-height=&quot;427&quot;/&gt;&lt;/figure&gt;&lt;p&gt;這樣好很多了吧?不過還不是最佳的, 由於顏色數變少了, 有些漸層的地方(比如說範例裡企鵝的脖子)會變成一條條帶狀的, 所以我們還需要做&lt;a href=&quot;https://en.wikipedia.org/wiki/Dither&quot;&gt;dithering&lt;/a&gt;, 在Go的image.draw裡其實已經有實作了Floyd Steinberg演算法, 因此可以用這個來做dithering, 程式就改成:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;i&gt;palette := q.Quantize(make(color.Palette, 0, 256), img)&lt;br/&gt;palImg := image.NewPaletted(img.Bounds(), palette)&lt;br/&gt;&lt;b&gt;draw.FloydSteinberg.Draw&lt;/b&gt;(palImg, img.Bounds(), img, image.ZP)&lt;/i&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;出來的結果是這樣:&lt;/p&gt;&lt;figure class=&quot;tmblr-full&quot; data-orig-height=&quot;427&quot; data-orig-width=&quot;640&quot;&gt;&lt;img src=&quot;http://65.media.tumblr.com/fd46ade278f31300568ad0ff54f230d0/tumblr_inline_nu9fhyPfU11qzg4zq_540.gif&quot; data-orig-height=&quot;427&quot; data-orig-width=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p&gt;細部的差異差不多像這樣:&lt;/p&gt;&lt;figure data-orig-height=&quot;77&quot; data-orig-width=&quot;101&quot;&gt;&lt;img src=&quot;http://65.media.tumblr.com/75a4ad1bd884ae6901c2da1a76d3f2f7/tumblr_inline_nu9fjzGcux1qzg4zq_540.png&quot; data-orig-height=&quot;77&quot; data-orig-width=&quot;101&quot;/&gt;&lt;/figure&gt;&lt;figure data-orig-height=&quot;59&quot; data-orig-width=&quot;101&quot;&gt;&lt;img src=&quot;http://66.media.tumblr.com/aca4ebea8f52a1a4c6acafc0684fa1c5/tumblr_inline_nu9fkeVmJn1qzg4zq_540.png&quot; data-orig-height=&quot;59&quot; data-orig-width=&quot;101&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二張是有dithering的(怎感覺比較醜)&lt;/p&gt;&lt;p&gt;總之, Happy GIFing~~~&lt;/p&gt;&lt;figure class=&quot;tmblr-full&quot; data-orig-height=&quot;269&quot; data-orig-width=&quot;500&quot; data-tumblr-attribution=&quot;animalgifdaily:boGnjFwTp3E-4HXa_X-JPg:ZVferr11zNOyj&quot;&gt;&lt;img src=&quot;http://65.media.tumblr.com/29149c292a1e8624fd913d098bf786c7/tumblr_my6exrY2DH1suyqwko1_500.gif&quot; data-orig-height=&quot;269&quot; data-orig-width=&quot;500&quot;/&gt;&lt;/figure&gt;</content><category term="golang" /><summary>最近在嘗試寫一些動態gif的應用, 所以就研究了一下怎用go去產生動態gif, 後來找到以下這篇:Go言語で画像の減色を行う其實這篇已經寫的蠻完整的了, 不過由它是日文(有很多日文的技術文章其實還不錯), 所以我嘗試用我自己的方法用中文再闡釋一遍要用輸出動態gif其實go就已經支援了, 使用EncodeAll即可:https://golang.org/pkg/image/gif/#EncodeAll不過, 仔細看一下GIF這個struct裡的那個Image陣列, 接受的是Paletted, 也就是附有調色盤的圖(色彩較少), 而現在大部分的圖片大多是全彩的, 因此, 需要先把全彩的圖轉成Paletted, 而這部份的作法是利用image.draw裡的Draw把全彩的圖畫到一個新的Paletted去:palImg := image.NewPaletted(img.Bounds(), palette.WebSafe)draw.Draw(palImg, img.Bounds(), img, image.ZP, draw.Over) 由於新創一個Paletted圖, 需要給它一個調色盤, 最簡單的方法是給它預設的調色盤, 在image.color.palette裡有兩個(plan9, web safe), 這邊採用了比較通用的Web safe, 最後輸出的結果如下:呃, 好醜&amp;hellip;..不過這是一定的, web safe一是組比較通用標準的色盤, 但大多數的顏色跟原本的圖的色彩差異可能相當的大, draw.Draw是在調色盤找出相近色, 但有可能找出來這顏色差異就很大了那怎麼辦?我們就必須對全彩影像找出最佳的調色盤, 從成千上萬色中找出適合的256種顏色, 這在影像處理技巧中有個叫Color quantization, 它就是用來處理這樣的狀況的在image.draw裡也找到了一個Quantizer:https://golang.org/src/image/draw/draw.go?s=688:910#L17不過看來這個Quantizer只有空殼(interface)並未有實作(也就是這樣我才去找到那篇日文的參考文章), 雖說, 實作一個median cut演算法不難, 但對懶人來說, 能有現成的當然最好, 從那篇參考文章中看到了, 有人幾經寫好的(更不錯的是已經實作了Quantizer) -https://github.com/soniakeys/quant/使用它後, 先前得程式碼可以簡單的改成 -q := median.Quantizer(256) //256個顏色palImg := q.Image(img)得到的結果會優很多:這樣好很多了吧?不過還不是最佳的, 由於顏色數變少了, 有些漸層的地方(比如說範例裡企鵝的脖子)會變成一條條帶狀的, 所以我們還需要做dithering, 在Go的image.draw裡其實已經有實作了Floyd Steinberg演算法, 因此可以用這個來做dithering, 程式就改成:palette := q.Quantize(make(color.Palette, 0, 256), img)palImg := image.NewPaletted(img.Bounds(), palette)draw.FloydSteinberg.Draw(palImg, img.Bounds(), img, image.ZP)出來的結果是這樣:細部的差異差不多像這樣:第二張是有dithering的(怎感覺比較醜)總之, Happy GIFing~~~</summary></entry></feed>
